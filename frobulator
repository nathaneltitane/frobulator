#!/bin/bash

# dependencies /////////////////////////////////////////////////////////////////

# script ///////////////////////////////////////////////////////////////////////

# version //////////////////////////////////////////////////////////////////////

# version="08-07-2023"

# variables ////////////////////////////////////////////////////////////////////

stamp=$(date +"%m-%d-%Y-%H-%M-%S")

# defaults /////////////////////////////////////////////////////////////////////

if [ -z "${SHELL}" ]
then
	shell=/bin/bash
else
	shell="${SHELL}"
fi

# provide fallback for non 'root' assessments

self="${0}"

if [ -z "${script}" ]
then
	script="${self}"
fi

# provide null sink for argument / error / output silencing

if [ -e /dev/null ]
then
	sink="/dev/null"
fi

# colors ///////////////////////////////////////////////////////////////////////

# 256 colors terminal [0-255]

# 0		Black				#000000	rgb(0,0,0)			hsl(0,0%,0%)
# 1		Maroon				#800000	rgb(128,0,0)		hsl(0,100%,25%)
# 2		Green				#008000	rgb(0,128,0)		hsl(120,100%,25%)
# 3		Olive				#808000	rgb(128,128,0)		hsl(60,100%,25%)
# 4		Navy				#000080	rgb(0,0,128)		hsl(240,100%,25%)
# 5		Purple				#800080	rgb(128,0,128)		hsl(300,100%,25%)
# 6		Teal				#008080	rgb(0,128,128)		hsl(180,100%,25%)
# 7		Silver				#c0c0c0	rgb(192,192,192)	hsl(0,0%,75%)
# 8		Grey				#808080	rgb(128,128,128)	hsl(0,0%,50%)
# 9		Red					#ff0000	rgb(255,0,0)		hsl(0,100%,50%)
# 10	Lime				#00ff00	rgb(0,255,0)		hsl(120,100%,50%)
# 11	Yellow				#ffff00	rgb(255,255,0)		hsl(60,100%,50%)
# 12	Blue				#0000ff	rgb(0,0,255)		hsl(240,100%,50%)
# 13	Fuchsia				#ff00ff	rgb(255,0,255)		hsl(300,100%,50%)
# 14	Aqua				#00ffff	rgb(0,255,255)		hsl(180,100%,50%)
# 15	White				#ffffff	rgb(255,255,255)	hsl(0,0%,100%)
# 16	Grey0				#000000	rgb(0,0,0)			hsl(0,0%,0%)
# 17	NavyBlue			#00005f	rgb(0,0,95)			hsl(240,100%,18%)
# 18	DarkBlue			#000087	rgb(0,0,135)		hsl(240,100%,26%)
# 19	Blue3				#0000af	rgb(0,0,175)		hsl(240,100%,34%)
# 20	Blue3				#0000d7	rgb(0,0,215)		hsl(240,100%,42%)
# 21	Blue1				#0000ff	rgb(0,0,255)		hsl(240,100%,50%)
# 22	DarkGreen			#005f00	rgb(0,95,0)			hsl(120,100%,18%)
# 23	DeepSkyBlue4		#005f5f	rgb(0,95,95)		hsl(180,100%,18%)
# 24	DeepSkyBlue4		#005f87	rgb(0,95,135)		hsl(97,100%,26%)
# 25	DeepSkyBlue4		#005faf	rgb(0,95,175)		hsl(07,100%,34%)
# 26	DodgerBlue3			#005fd7	rgb(0,95,215)		hsl(13,100%,42%)
# 27	DodgerBlue2			#005fff	rgb(0,95,255)		hsl(17,100%,50%)
# 28	Green4				#008700	rgb(0,135,0)		hsl(120,100%,26%)
# 29	SpringGreen4		#00875f	rgb(0,135,95)		hsl(62,100%,26%)
# 30	Turquoise4			#008787	rgb(0,135,135)		hsl(180,100%,26%)
# 31	DeepSkyBlue3		#0087af	rgb(0,135,175)		hsl(93,100%,34%)
# 32	DeepSkyBlue3		#0087d7	rgb(0,135,215)		hsl(02,100%,42%)
# 33	DodgerBlue1			#0087ff	rgb(0,135,255)		hsl(08,100%,50%)
# 34	Green3				#00af00	rgb(0,175,0)		hsl(120,100%,34%)
# 35	SpringGreen3		#00af5f	rgb(0,175,95)		hsl(52,100%,34%)
# 36	DarkCyan			#00af87	rgb(0,175,135)		hsl(66,100%,34%)
# 37	LightSeaGreen		#00afaf	rgb(0,175,175)		hsl(180,100%,34%)
# 38	DeepSkyBlue2		#00afd7	rgb(0,175,215)		hsl(91,100%,42%)
# 39	DeepSkyBlue1		#00afff	rgb(0,175,255)		hsl(98,100%,50%)
# 40	Green3				#00d700	rgb(0,215,0)		hsl(120,100%,42%)
# 41	SpringGreen3		#00d75f	rgb(0,215,95)		hsl(46,100%,42%)
# 42	SpringGreen2		#00d787	rgb(0,215,135)		hsl(57,100%,42%)
# 43	Cyan3				#00d7af	rgb(0,215,175)		hsl(68,100%,42%)
# 44	DarkTurquoise		#00d7d7	rgb(0,215,215)		hsl(180,100%,42%)
# 45	Turquoise2			#00d7ff	rgb(0,215,255)		hsl(89,100%,50%)
# 46	Green1				#00ff00	rgb(0,255,0)		hsl(120,100%,50%)
# 47	SpringGreen2		#00ff5f	rgb(0,255,95)		hsl(42,100%,50%)
# 48	SpringGreen1		#00ff87	rgb(0,255,135)		hsl(51,100%,50%)
# 49	MediumSpringGreen	#00ffaf	rgb(0,255,175)		hsl(61,100%,50%)
# 50	Cyan2				#00ffd7	rgb(0,255,215)		hsl(70,100%,50%)
# 51	Cyan1				#00ffff	rgb(0,255,255)		hsl(180,100%,50%)
# 52	DarkRed				#5f0000	rgb(95,0,0)			hsl(0,100%,18%)
# 53	DeepPink4			#5f005f	rgb(95,0,95)		hsl(300,100%,18%)
# 54	Purple4				#5f0087	rgb(95,0,135)		hsl(82,100%,26%)
# 55	Purple4				#5f00af	rgb(95,0,175)		hsl(72,100%,34%)
# 56	Purple3				#5f00d7	rgb(95,0,215)		hsl(66,100%,42%)
# 57	BlueViolet			#5f00ff	rgb(95,0,255)		hsl(62,100%,50%)
# 58	Orange4				#5f5f00	rgb(95,95,0)		hsl(60,100%,18%)
# 59	Grey37				#5f5f5f	rgb(95,95,95)		hsl(0,0%,37%)
# 60	MediumPurple4		#5f5f87	rgb(95,95,135)		hsl(240,17%,45%)
# 61	SlateBlue3			#5f5faf	rgb(95,95,175)		hsl(240,33%,52%)
# 62	SlateBlue3			#5f5fd7	rgb(95,95,215)		hsl(240,60%,60%)
# 63	RoyalBlue1			#5f5fff	rgb(95,95,255)		hsl(240,100%,68%)
# 64	Chartreuse4			#5f8700	rgb(95,135,0)		hsl(7,100%,26%)
# 65	DarkSeaGreen4		#5f875f	rgb(95,135,95)		hsl(120,17%,45%)
# 66	PaleTurquoise4		#5f8787	rgb(95,135,135)		hsl(180,17%,45%)
# 67	SteelBlue			#5f87af	rgb(95,135,175)		hsl(210,33%,52%)
# 68	SteelBlue3			#5f87d7	rgb(95,135,215)		hsl(220,60%,60%)
# 69	CornflowerBlue		#5f87ff	rgb(95,135,255)		hsl(225,100%,68%)
# 70	Chartreuse3			#5faf00	rgb(95,175,0)		hsl(7,100%,34%)
# 71	DarkSeaGreen4		#5faf5f	rgb(95,175,95)		hsl(120,33%,52%)
# 72	CadetBlue			#5faf87	rgb(95,175,135)		hsl(150,33%,52%)
# 73	CadetBlue			#5fafaf	rgb(95,175,175)		hsl(180,33%,52%)
# 74	SkyBlue3			#5fafd7	rgb(95,175,215)		hsl(200,60%,60%)
# 75	SteelBlue1			#5fafff	rgb(95,175,255)		hsl(210,100%,68%)
# 76	Chartreuse3			#5fd700	rgb(95,215,0)		hsl(3,100%,42%)
# 77	PaleGreen3			#5fd75f	rgb(95,215,95)		hsl(120,60%,60%)
# 78	SeaGreen3			#5fd787	rgb(95,215,135)		hsl(140,60%,60%)
# 79	Aquamarine3			#5fd7af	rgb(95,215,175)		hsl(160,60%,60%)
# 80	MediumTurquoise		#5fd7d7	rgb(95,215,215)		hsl(180,60%,60%)
# 81	SteelBlue1			#5fd7ff	rgb(95,215,255)		hsl(195,100%,68%)
# 82	Chartreuse2			#5fff00	rgb(95,255,0)		hsl(7,100%,50%)
# 83	SeaGreen2			#5fff5f	rgb(95,255,95)		hsl(120,100%,68%)
# 84	SeaGreen1			#5fff87	rgb(95,255,135)		hsl(135,100%,68%)
# 85	SeaGreen1			#5fffaf	rgb(95,255,175)		hsl(150,100%,68%)
# 86	Aquamarine1			#5fffd7	rgb(95,255,215)		hsl(165,100%,68%)
# 87	DarkSlateGray2		#5fffff	rgb(95,255,255)		hsl(180,100%,68%)
# 88	DarkRed				#870000	rgb(135,0,0)		hsl(0,100%,26%)
# 89	DeepPink4			#87005f	rgb(135,0,95)		hsl(17,100%,26%)
# 90	DarkMagenta			#870087	rgb(135,0,135)		hsl(300,100%,26%)
# 91	DarkMagenta			#8700af	rgb(135,0,175)		hsl(86,100%,34%)
# 92	DarkViolet			#8700d7	rgb(135,0,215)		hsl(77,100%,42%)
# 93	Purple				#8700ff	rgb(135,0,255)		hsl(71,100%,50%)
# 94	Orange4				#875f00	rgb(135,95,0)		hsl(2,100%,26%)
# 95	LightPink4			#875f5f	rgb(135,95,95)		hsl(0,17%,45%)
# 96	Plum4				#875f87	rgb(135,95,135)		hsl(300,17%,45%)
# 97	MediumPurple3		#875faf	rgb(135,95,175)		hsl(270,33%,52%)
# 98	MediumPurple3		#875fd7	rgb(135,95,215)		hsl(260,60%,60%)
# 99	SlateBlue1			#875fff	rgb(135,95,255)		hsl(255,100%,68%)
# 100	Yellow4				#878700	rgb(135,135,0)		hsl(60,100%,26%)
# 101	Wheat4				#87875f	rgb(135,135,95)		hsl(60,17%,45%)
# 102	Grey53				#878787	rgb(135,135,135)	hsl(0,0%,52%)
# 103	LightSlateGrey		#8787af	rgb(135,135,175)	hsl(240,20%,60%)
# 104	MediumPurple		#8787d7	rgb(135,135,215)	hsl(240,50%,68%)
# 105	LightSlateBlue		#8787ff	rgb(135,135,255)	hsl(240,100%,76%)
# 106	Yellow4				#87af00	rgb(135,175,0)		hsl(3,100%,34%)
# 107	DarkOliveGreen3		#87af5f	rgb(135,175,95)		hsl(90,33%,52%)
# 108	DarkSeaGreen		#87af87	rgb(135,175,135)	hsl(120,20%,60%)
# 109	LightSkyBlue3		#87afaf	rgb(135,175,175)	hsl(180,20%,60%)
# 110	LightSkyBlue3		#87afd7	rgb(135,175,215)	hsl(210,50%,68%)
# 111	SkyBlue2			#87afff	rgb(135,175,255)	hsl(220,100%,76%)
# 112	Chartreuse2			#87d700	rgb(135,215,0)		hsl(2,100%,42%)
# 113	DarkOliveGreen3		#87d75f	rgb(135,215,95)		hsl(100,60%,60%)
# 114	PaleGreen3			#87d787	rgb(135,215,135)	hsl(120,50%,68%)
# 115	DarkSeaGreen3		#87d7af	rgb(135,215,175)	hsl(150,50%,68%)
# 116	DarkSlateGray3		#87d7d7	rgb(135,215,215)	hsl(180,50%,68%)
# 117	SkyBlue1			#87d7ff	rgb(135,215,255)	hsl(200,100%,76%)
# 118	Chartreuse1			#87ff00	rgb(135,255,0)		hsl(8,100%,50%)
# 119	LightGreen			#87ff5f	rgb(135,255,95)		hsl(105,100%,68%)
# 120	LightGreen			#87ff87	rgb(135,255,135)	hsl(120,100%,76%)
# 121	PaleGreen1			#87ffaf	rgb(135,255,175)	hsl(140,100%,76%)
# 122	Aquamarine1			#87ffd7	rgb(135,255,215)	hsl(160,100%,76%)
# 123	DarkSlateGray1		#87ffff	rgb(135,255,255)	hsl(180,100%,76%)
# 124	Red3				#af0000	rgb(175,0,0)		hsl(0,100%,34%)
# 125	DeepPink4			#af005f	rgb(175,0,95)		hsl(27,100%,34%)
# 126	MediumVioletRed		#af0087	rgb(175,0,135)		hsl(13,100%,34%)
# 127	Magenta3			#af00af	rgb(175,0,175)		hsl(300,100%,34%)
# 128	DarkViolet			#af00d7	rgb(175,0,215)		hsl(88,100%,42%)
# 129	Purple				#af00ff	rgb(175,0,255)		hsl(81,100%,50%)
# 130	DarkOrange3			#af5f00	rgb(175,95,0)		hsl(2,100%,34%)
# 131	IndianRed			#af5f5f	rgb(175,95,95)		hsl(0,33%,52%)
# 132	HotPink3			#af5f87	rgb(175,95,135)		hsl(330,33%,52%)
# 133	MediumOrchid3		#af5faf	rgb(175,95,175)		hsl(300,33%,52%)
# 134	MediumOrchid		#af5fd7	rgb(175,95,215)		hsl(280,60%,60%)
# 135	MediumPurple2		#af5fff	rgb(175,95,255)		hsl(270,100%,68%)
# 136	DarkGoldenrod		#af8700	rgb(175,135,0)		hsl(6,100%,34%)
# 137	LightSalmon3		#af875f	rgb(175,135,95)		hsl(30,33%,52%)
# 138	RosyBrown			#af8787	rgb(175,135,135)	hsl(0,20%,60%)
# 139	Grey63				#af87af	rgb(175,135,175)	hsl(300,20%,60%)
# 140	MediumPurple2		#af87d7	rgb(175,135,215)	hsl(270,50%,68%)
# 141	MediumPurple1		#af87ff	rgb(175,135,255)	hsl(260,100%,76%)
# 142	Gold3				#afaf00	rgb(175,175,0)		hsl(60,100%,34%)
# 143	DarkKhaki			#afaf5f	rgb(175,175,95)		hsl(60,33%,52%)
# 144	NavajoWhite3		#afaf87	rgb(175,175,135)	hsl(60,20%,60%)
# 145	Grey69				#afafaf	rgb(175,175,175)	hsl(0,0%,68%)
# 146	LightSteelBlue3		#afafd7	rgb(175,175,215)	hsl(240,33%,76%)
# 147	LightSteelBlue		#afafff	rgb(175,175,255)	hsl(240,100%,84%)
# 148	Yellow3				#afd700	rgb(175,215,0)		hsl(1,100%,42%)
# 149	DarkOliveGreen3		#afd75f	rgb(175,215,95)		hsl(80,60%,60%)
# 150	DarkSeaGreen3		#afd787	rgb(175,215,135)	hsl(90,50%,68%)
# 151	DarkSeaGreen2		#afd7af	rgb(175,215,175)	hsl(120,33%,76%)
# 152	LightCyan3			#afd7d7	rgb(175,215,215)	hsl(180,33%,76%)
# 153	LightSkyBlue1		#afd7ff	rgb(175,215,255)	hsl(210,100%,84%)
# 154	GreenYellow			#afff00	rgb(175,255,0)		hsl(8,100%,50%)
# 155	DarkOliveGreen2		#afff5f	rgb(175,255,95)		hsl(90,100%,68%)
# 156	PaleGreen1			#afff87	rgb(175,255,135)	hsl(100,100%,76%)
# 157	DarkSeaGreen2		#afffaf	rgb(175,255,175)	hsl(120,100%,84%)
# 158	DarkSeaGreen1		#afffd7	rgb(175,255,215)	hsl(150,100%,84%)
# 159	PaleTurquoise1		#afffff	rgb(175,255,255)	hsl(180,100%,84%)
# 160	Red3				#d70000	rgb(215,0,0)		hsl(0,100%,42%)
# 161	DeepPink3			#d7005f	rgb(215,0,95)		hsl(33,100%,42%)
# 162	DeepPink3			#d70087	rgb(215,0,135)		hsl(22,100%,42%)
# 163	Magenta3			#d700af	rgb(215,0,175)		hsl(11,100%,42%)
# 164	Magenta3			#d700d7	rgb(215,0,215)		hsl(300,100%,42%)
# 165	Magenta2			#d700ff	rgb(215,0,255)		hsl(90,100%,50%)
# 166	DarkOrange3			#d75f00	rgb(215,95,0)		hsl(6,100%,42%)
# 167	IndianRed			#d75f5f	rgb(215,95,95)		hsl(0,60%,60%)
# 168	HotPink3			#d75f87	rgb(215,95,135)		hsl(340,60%,60%)
# 169	HotPink2			#d75faf	rgb(215,95,175)		hsl(320,60%,60%)
# 170	Orchid				#d75fd7	rgb(215,95,215)		hsl(300,60%,60%)
# 171	MediumOrchid1		#d75fff	rgb(215,95,255)		hsl(285,100%,68%)
# 172	Orange3				#d78700	rgb(215,135,0)		hsl(7,100%,42%)
# 173	LightSalmon3		#d7875f	rgb(215,135,95)		hsl(20,60%,60%)
# 174	LightPink3			#d78787	rgb(215,135,135)	hsl(0,50%,68%)
# 175	Pink3				#d787af	rgb(215,135,175)	hsl(330,50%,68%)
# 176	Plum3				#d787d7	rgb(215,135,215)	hsl(300,50%,68%)
# 177	Violet				#d787ff	rgb(215,135,255)	hsl(280,100%,76%)
# 178	Gold3				#d7af00	rgb(215,175,0)		hsl(8,100%,42%)
# 179	LightGoldenrod3		#d7af5f	rgb(215,175,95)		hsl(40,60%,60%)
# 180	Tan					#d7af87	rgb(215,175,135)	hsl(30,50%,68%)
# 181	MistyRose3			#d7afaf	rgb(215,175,175)	hsl(0,33%,76%)
# 182	Thistle3			#d7afd7	rgb(215,175,215)	hsl(300,33%,76%)
# 183	Plum2				#d7afff	rgb(215,175,255)	hsl(270,100%,84%)
# 184	Yellow3				#d7d700	rgb(215,215,0)		hsl(60,100%,42%)
# 185	Khaki3				#d7d75f	rgb(215,215,95)		hsl(60,60%,60%)
# 186	LightGoldenrod2		#d7d787	rgb(215,215,135)	hsl(60,50%,68%)
# 187	LightYellow3		#d7d7af	rgb(215,215,175)	hsl(60,33%,76%)
# 188	Grey84				#d7d7d7	rgb(215,215,215)	hsl(0,0%,84%)
# 189	LightSteelBlue1		#d7d7ff	rgb(215,215,255)	hsl(240,100%,92%)
# 190	Yellow2				#d7ff00	rgb(215,255,0)		hsl(9,100%,50%)
# 191	DarkOliveGreen1		#d7ff5f	rgb(215,255,95)		hsl(75,100%,68%)
# 192	DarkOliveGreen1		#d7ff87	rgb(215,255,135)	hsl(80,100%,76%)
# 193	DarkSeaGreen1		#d7ffaf	rgb(215,255,175)	hsl(90,100%,84%)
# 194	Honeydew2			#d7ffd7	rgb(215,255,215)	hsl(120,100%,92%)
# 195	LightCyan1			#d7ffff	rgb(215,255,255)	hsl(180,100%,92%)
# 196	Red1				#ff0000	rgb(255,0,0)		hsl(0,100%,50%)
# 197	DeepPink2			#ff005f	rgb(255,0,95)		hsl(37,100%,50%)
# 198	DeepPink1			#ff0087	rgb(255,0,135)		hsl(28,100%,50%)
# 199	DeepPink1			#ff00af	rgb(255,0,175)		hsl(18,100%,50%)
# 200	Magenta2			#ff00d7	rgb(255,0,215)		hsl(09,100%,50%)
# 201	Magenta1			#ff00ff	rgb(255,0,255)		hsl(300,100%,50%)
# 202	OrangeRed1			#ff5f00	rgb(255,95,0)		hsl(2,100%,50%)
# 203	IndianRed1			#ff5f5f	rgb(255,95,95)		hsl(0,100%,68%)
# 204	IndianRed1			#ff5f87	rgb(255,95,135)		hsl(345,100%,68%)
# 205	HotPink				#ff5faf	rgb(255,95,175)		hsl(330,100%,68%)
# 206	HotPink				#ff5fd7	rgb(255,95,215)		hsl(315,100%,68%)
# 207	MediumOrchid1		#ff5fff	rgb(255,95,255)		hsl(300,100%,68%)
# 208	DarkOrange			#ff8700	rgb(255,135,0)		hsl(1,100%,50%)
# 209	Salmon1				#ff875f	rgb(255,135,95)		hsl(15,100%,68%)
# 210	LightCoral			#ff8787	rgb(255,135,135)	hsl(0,100%,76%)
# 211	PaleVioletRed1		#ff87af	rgb(255,135,175)	hsl(340,100%,76%)
# 212	Orchid2				#ff87d7	rgb(255,135,215)	hsl(320,100%,76%)
# 213	Orchid1				#ff87ff	rgb(255,135,255)	hsl(300,100%,76%)
# 214	Orange1				#ffaf00	rgb(255,175,0)		hsl(1,100%,50%)
# 215	SandyBrown			#ffaf5f	rgb(255,175,95)		hsl(30,100%,68%)
# 216	LightSalmon1		#ffaf87	rgb(255,175,135)	hsl(20,100%,76%)
# 217	LightPink1			#ffafaf	rgb(255,175,175)	hsl(0,100%,84%)
# 218	Pink1				#ffafd7	rgb(255,175,215)	hsl(330,100%,84%)
# 219	Plum1				#ffafff	rgb(255,175,255)	hsl(300,100%,84%)
# 220	Gold1				#ffd700	rgb(255,215,0)		hsl(0,100%,50%)
# 221	LightGoldenrod2		#ffd75f	rgb(255,215,95)		hsl(45,100%,68%)
# 222	LightGoldenrod2		#ffd787	rgb(255,215,135)	hsl(40,100%,76%)
# 223	NavajoWhite1		#ffd7af	rgb(255,215,175)	hsl(30,100%,84%)
# 224	MistyRose1			#ffd7d7	rgb(255,215,215)	hsl(0,100%,92%)
# 225	Thistle1			#ffd7ff	rgb(255,215,255)	hsl(300,100%,92%)
# 226	Yellow1				#ffff00	rgb(255,255,0)		hsl(60,100%,50%)
# 227	LightGoldenrod1		#ffff5f	rgb(255,255,95)		hsl(60,100%,68%)
# 228	Khaki1				#ffff87	rgb(255,255,135)	hsl(60,100%,76%)
# 229	Wheat1				#ffffaf	rgb(255,255,175)	hsl(60,100%,84%)
# 230	Cornsilk1			#ffffd7	rgb(255,255,215)	hsl(60,100%,92%)
# 231	Grey100				#ffffff	rgb(255,255,255)	hsl(0,0%,100%)
# 232	Grey3				#080808	rgb(8,8,8)			hsl(0,0%,3%)
# 233	Grey7				#121212	rgb(18,18,18)		hsl(0,0%,7%)
# 234	Grey11				#1c1c1c	rgb(28,28,28)		hsl(0,0%,10%)
# 235	Grey15				#262626	rgb(38,38,38)		hsl(0,0%,14%)
# 236	Grey19				#303030	rgb(48,48,48)		hsl(0,0%,18%)
# 237	Grey23				#3a3a3a	rgb(58,58,58)		hsl(0,0%,22%)
# 238	Grey27				#444444	rgb(68,68,68)		hsl(0,0%,26%)
# 239	Grey30				#4e4e4e	rgb(78,78,78)		hsl(0,0%,30%)
# 240	Grey35				#585858	rgb(88,88,88)		hsl(0,0%,34%)
# 241	Grey39				#626262	rgb(98,98,98)		hsl(0,0%,37%)
# 242	Grey42				#6c6c6c	rgb(108,108,108)	hsl(0,0%,40%)
# 243	Grey46				#767676	rgb(118,118,118)	hsl(0,0%,46%)
# 244	Grey50				#808080	rgb(128,128,128)	hsl(0,0%,50%)
# 245	Grey54				#8a8a8a	rgb(138,138,138)	hsl(0,0%,54%)
# 246	Grey58				#949494	rgb(148,148,148)	hsl(0,0%,58%)
# 247	Grey62				#9e9e9e	rgb(158,158,158)	hsl(0,0%,61%)
# 248	Grey66				#a8a8a8	rgb(168,168,168)	hsl(0,0%,65%)
# 249	Grey70				#b2b2b2	rgb(178,178,178)	hsl(0,0%,69%)
# 250	Grey74				#bcbcbc	rgb(188,188,188)	hsl(0,0%,73%)
# 251	Grey78				#c6c6c6	rgb(198,198,198)	hsl(0,0%,77%)
# 252	Grey82				#d0d0d0	rgb(208,208,208)	hsl(0,0%,81%)
# 253	Grey85				#dadada	rgb(218,218,218)	hsl(0,0%,85%)
# 254	Grey89				#e4e4e4	rgb(228,228,228)	hsl(0,0%,89%)
# 255	Grey93				#eeeeee	rgb(238,238,238)	hsl(0,0%,93%)

# set colors selection

colors_selection=(
	white="255"
	silver="248"
	grey="243"
	black="238"

	red="1"
	crimson="88"

	green="2"
	lime="28"

	yellow="11"
	orange="202"

	blue="4"
	navy="26"

	magenta="5"
	purple="53"

	fuschia="126"
	pink="200"

	aqua="6"
	teal="30"
)

if [ -z "$(command -v tput)" ]
then
	# handle color digit length for ansi fallback method

	for color in ${colors_selection[@]}
	do
		IFS='='

		read color_name color_value <<< "${color}"

		if [ ${#color_value} = 3 ]
		then
			color_value="${color_value}"
		fi

		if [ ${#color_value} = 2 ]
		then
			color_value="0${color_value}"
		fi

		if [ ${#color_value} = 1 ]
		then
			color_value="00${color_value}"
		fi

		IFS=''

		eval "${color_name}=${color_value}"
	done

	# ansi color attributes

	if [[ -t 1 ]]
	then
		# monochromatic colors

		white=$(echo -e \\e\[38\;5\;"${white}"m)
		silver=$(echo -e \\e\[38\;5\;"${silver}"m)
		grey=$(echo -e \\e\[38\;5\;"${grey}"m)
		black=$(echo -e \\e\[38\;5\;"${black}"m)

		# standard colors by sturation offset

		red=$(echo -e \\e\[38\;5\;"${red}"m)
		crimson=$(echo -e \\e\[38\;5\;"${crimson}"m)

		green=$(echo -e \\e\[38\;5\;"${green}"m)
		lime=$(echo -e \\e\[38\;5\;"${lime}"m)

		yellow=$(echo -e \\e\[38\;5\;"${yellow}"m)
		orange=$(echo -e \\e\[38\;5\;"${orange}"m)

		blue=$(echo -e \\e\[38\;5\;"${blue}"m)
		navy=$(echo -e \\e\[38\;5\;"${navy}"m)

		magenta=$(echo -e \\e\[38\;5\;"${magenta}"m)
		purple=$(echo -e \\e\[38\;5\;"${purple}"m)

		aqua=$(echo -e \\e\[38\;5\;"${aqua}"m)
		teal=$(echo -e \\e\[38\;5\;"${teal}"m)

		# reset all attributes

		reset=$(echo -e \\e\[39m)
	fi
else
	# 'tput' colors and attributes

	if [[ -t 1 ]]
	then
		# monochromatic colors

		white=$(tput setaf "${white}")
		silver=$(tput setaf "${silver}")
		grey=$(tput setaf "${grey}")
		black=$(tput setaf "${black}")

		# standard colors by sturation offset

		red=$(tput setaf "${red}")
		crimson=$(tput setaf "${crimson}")

		green=$(tput setaf "${green}")
		lime=$(tput setaf "${lime}")

		yellow=$(tput setaf "${yellow}")
		orange=$(tput setaf "${orange}")

		blue=$(tput setaf "${blue}")
		navy=$(tput setaf "${navy}")

		magenta=$(tput setaf "${magenta}")
		purple=$(tput setaf "${purple}")

		fuschia=$(tput setaf "${fuschia}")
		pink=$(tput setaf "${pink}")

		aqua=$(tput setaf "${aqua}")
		teal=$(tput setaf "${teal}")

		# reset all attributes

		reset=$(tput sgr 0)

		# 'tput' terminal control

		# full description of terminal capacity

		terminal_info=$(tput longname)

		# number of lines in terminal

		terminal_height=$(tput lines)

		# number of columns in terminal

		terminal_width=$(tput cols)

		# number of colors available

		terminal_colors=$(tput colors)

		# save cursor position of terminal

		terminal_save_cursor=$(tput sc)

		# restore cursor position of terminal

		terminal_restore_cursor=$(tput rc)

		# move cursor to upper left corner (0,0) - equivalent: 'tput cup 0 0'

		terminal_home_cursor=$(tput home)

		# move cursor to position (row, column)

		terminal_move_cursor=$(tput cup ${tput_row} ${tput_col})

		# move cursor down 1 row

		terminal_cursor_down=$(tput cud1)

		# move cursor up 1 row

		terminal_cursor_up=$(tput cuu1)

		# set cursor to invisible state

		terminal_cursor_hide=$(tput civis)

		# set cursor to normal state

		terminal_cursor_show=$(tput cnorm)

		# save screen contents

		terminal_save_screen=$(tput smcup)

		# restore screen contents

		terminal_restore_screen=$(tput rmcup)

		# clear from cursor to end of line - left

		terminal_clear_right=$(tput el1)

		# clear from cursor to beginning of line - right

		terminal_clear_left=$(tput el)

		# clear from cursor to end of the screen - down

		terminal_clear_down=$(tput ed)

		# clear entire screen and home cursor (0,0) - all

		terminal_clear_all=$(tput clear)
	fi
fi

# markers //////////////////////////////////////////////////////////////////////

marker_top='[ ‚ñ≥ ]'
marker_bot='[ ‚ñΩ ]'

marker_fwd='[ ‚ñ∑ ]'
marker_rev='[ ‚óÅ ]'
marker_stp='[ ‚ñ° ]'

marker_add='[ + ]'
marker_rem='[ - ]'

marker_ret='[ ‚óè ]'
marker_rel='[ ‚óã ]'

marker_ask='[ ? ]'
marker_inf='[ i ]'
marker_wrn='[ ! ]'

marker_ipt='[ > ]'
marker_msg='[ # ]'
marker_usr='[ ~ ]'

marker_yes='[ ‚úì ]'
marker_not='[ êÑÇ ]'

marker_nul='     '

# prompt ///////////////////////////////////////////////////////////////////////

# standard prompt with 80 charcters width:
# uses line folding with word detection for strings over 80 characters long

frobulator.prompt () {
	# initialize string return array

	frobulator_string=()

	begin="${1}"
	end="${2}"

	# provide fallback for line character count

	if [ -z "${count}" ]
	then
		count=80
	fi

	# set span width

	if [ ${#begin} -le "${count}" ]
	then
		span="--------------------------------------------------------------------------------"
	else
		span=""
	fi

	# parse arguments

	# 0 argument - full dash line

	if [ $# -ge 0 ]
	then
		span_character="/"
	fi

	# 1 argument - pad to end of line

	if [ $# -eq 1 ]
	then
		span_character="/"
	fi

	# 3 arguments - replace span character with argument 3

	if [ $# -eq 3 ]
	then
		span_character="${3}"

		if [ ${#span_character} -gt 1 ]
		then
			count=$((${count} / ${#span_character}))
		fi
	fi

	# 2+ arguments - reduce span by 6 characters:
	# compensate for line marker + space

	if [ $# -ge 2 ]
	then
		span=${span::-6}
	fi

	# 2+ arguments - append space to 'begin' value

	if [ $# -ge 2 ]
	then
		begin="${begin} "
	fi

	# 2+ arguments - prepend space to 'end' value

	if [ $# -ge 2 ]
	then
		end=" ${end}"
	fi

	# 75+ characters per single string:
	# fold string using word detection at limit
	# to prevent overstepping 80 characters overall limit
	# indent second line onward (6 spaces) to match line marker
	# detect newline character and indent onward (6 spaces) to match line marker

	margin=5

	fold=$(( "${count}" - "${margin}" ))

	if [ $# -eq 1 ] && [ "${#begin}" -ge "${fold}" ]
	then
		begin=$(echo "${begin}" | fold -s -w "${fold}" | sed -e '2,$s/^/      /g' | sed 's/ \\n /\\n\n      /g')
	fi

	# substitute span character

	span="${span//-/$span_character}"

	# print first argument

	span_begin=$(echo -n -e "${begin}")

	# print other arguments as fixed width prompt if present:
	# calculate span width - remove 6 characters for prompt header

	span_count=$(( ${#span} - ${#begin} - ${#end} ))

	# set new padding width ///////////////////////////////////////// # FIX ME #

	if [ ${#begin} -le "${count}" ]
	then
		span=${span:0:$span_count}
	else
		span=""
	fi

	# /////////////////////////////////////////////////////////////// # FIX ME #

	span_middle="${span}"

	span_end=$(echo -e "${end}")

	# populate array at end to avoid integrating spaces

	if [ $# -ge 0 ]
	then
		frobulator_string=("${span_begin}""${span_middle}""${span_end}")
	fi

	if [ $# -eq 1 ]
	then
		frobulator_string=("${span_begin}")
	fi

	if [ $# -ge 2 ]
	then
		frobulator_string=("${span_begin}""${span_middle}""${span_end}")
	fi

	if [ $# -eq 3 ]
	then
		frobulator_string=("${span_begin}""${span_middle}""${span_end}")
	fi
}

# highlights ///////////////////////////////////////////////////////////////////

# colored string highlights with built-in prompt arguments and line padding
#
# usage:      frobulator.[color] "[string]" "[string]" "[span character]"
#
# command:    frobulator.[color] "[string]"
# result:     string
#
# command:    frobulator.[color] "[string]" "[string]"
# result:     string ///////////////////////////////////////////////////////////// string
#
# command:    frobulator.[color] "[string]" "[string]" "[\]"
# result:     string \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ string

frobulator.black () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${black}${value}${reset}"
}

frobulator.silver () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${silver}${value}${reset}"
}

frobulator.grey () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${grey}${value}${reset}"
}

frobulator.white () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${white}${value}${reset}"
}

frobulator.red () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${red}${value}${reset}"
}

frobulator.crimson () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${crimson}${value}${reset}"
}

frobulator.green () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${green}${value}${reset}"
}

frobulator.lime () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${lime}${value}${reset}"
}

frobulator.yellow () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${yellow}${value}${reset}"
}

frobulator.orange () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${orange}${value}${reset}"
}

frobulator.blue () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${blue}${value}${reset}"
}

frobulator.navy () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${navy}${value}${reset}"
}

frobulator.magenta () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${magenta}${value}${reset}"
}

frobulator.purple () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${purple}${value}${reset}"
}

frobulator.fuschia () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${fuschia}${value}${reset}"
}

frobulator.pink () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${pink}${value}${reset}"
}

frobulator.aqua () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${aqua}${value}${reset}"
}

frobulator.teal () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${teal}${value}${reset}"
}

# prompt marking ///////////////////////////////////////////////////////////////

# colored string highlights with built-in prompt arguments, line padding and line markers

# usage:      frobulator.[color] "[string]" "[string]" "[span character]"

# command:    frobulator.[color] "[string]"
# result:     string

# command:    frobulator.[color] "[string]" "[string]"
# result:     string ///////////////////////////////////////////////////////////// string

# command:    frobulator.[color] "[string]" "[string]" "[\]"
# result:     string \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ string

# line markers:

# top [ ‚ñ≥ ]
# bot [ ‚ñΩ ]

# fwd [ ‚ñ∑ ]
# rev [ ‚óÅ ]
# stp [ ‚ñ° ]

# add [ + ]
# rem [ - ]

# ret [ ‚óè ]
# rel [ ‚óã ]

# ask [ ? ]
# inf [ i ]
# wrn [ ! ]

# ipt [ > ]
# msg [ # ]
# usr [ ~ ]

# yes [ ‚úì ]
# not [ êÑÇ ]

# nul '     '

# information line marker //////////////////////////////////////////////////////

frobulator.inf () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${blue}${marker_inf} ${value}${reset}"

	color=($_)
}

# warning line marker //////////////////////////////////////////////////////

frobulator.wrn () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${orange}${marker_wrn} ${value}${reset}"

	color=($_)
}

# message line marker //////////////////////////////////////////////////////////

frobulator.msg () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${navy}${marker_msg} ${value}${reset}"

	color=($_)
}

# add line marker //////////////////////////////////////////////////////////////

frobulator.add () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${lime}${marker_add} ${value}${reset}"

	color=($_)
}

# remove line marker ///////////////////////////////////////////////////////////

frobulator.rem () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${crimson}${marker_rem} ${value}${reset}"

	color=($_)
}

# retain line marker ///////////////////////////////////////////////////////////

frobulator.ret () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${aqua}${marker_ret} ${value}${reset}"

	color=($_)
}

# release line marker //////////////////////////////////////////////////////////

frobulator.rel () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${teal}${marker_rel} ${value}${reset}"

	color=($_)
}

# forward line marker //////////////////////////////////////////////////////////

frobulator.fwd () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${silver}${marker_fwd} ${value}${reset}"

	color=($_)
}

# reverse line marker //////////////////////////////////////////////////////////

frobulator.rev () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${silver}${marker_rev} ${value}${reset}"

	color=($_)
}

# stop line marker /////////////////////////////////////////////////////////////

frobulator.stp () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${grey}${marker_stp} ${value}${reset}"

	color=($_)
}

# download line marker /////////////////////////////////////////////////////////

frobulator.dwl () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${magenta}${marker_bot} ${value}${reset}"

	color=($_)
}

# upload line marker ///////////////////////////////////////////////////////////

frobulator.upl () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${purple}${marker_top} ${value}${reset}"

	color=($_)
}

# link line marker /////////////////////////////////////////////////////////////

frobulator.lnk () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${yellow}${marker_stp} ${value}${reset}"

	color=($_)
}

# success line marker //////////////////////////////////////////////////////////

frobulator.scs () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${green}${marker_yes} ${value}${reset}"

	color=($_)
}

# error line marker ////////////////////////////////////////////////////////////

frobulator.err () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${red}${marker_not} ${value}${reset}"

	color=($_)
}

# insert line marker ///////////////////////////////////////////////////////////

frobulator.ins () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${teal}${marker_ipt} ${value}${reset}"

	color=($_)
}

# user input prompts ///////////////////////////////////////////////////////////

# use for questions, input, user input dependant inquiries

# note:
# use 'echo -n -e' to prevent adding new line after prompt:
# keeps user input beside prompt
# also includes space after value to separate input

# ask line marker //////////////////////////////////////////////////////////////

frobulator.ask () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -n -e "${fuschia}${marker_ask} ${value} ${reset}"

	color=($_)
}

# input line marker ////////////////////////////////////////////////////////////

frobulator.ipt () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -n -e "${pink}${marker_add} ${value} ${reset}"

	color=($_)
}

# user line marker /////////////////////////////////////////////////////////////

frobulator.usr () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -n -e "${grey}${marker_usr} ${value} ${reset}"

	color=($_)
}

# null /////////////////////////////////////////////////////////////////////////

# use to carry over prompts without adding a line marker while retaining color

frobulator.nul () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	color="${color::-1}"

	echo -e "${color}${marker_nul} ${value}${reset}"
}

# null /////////////////////////////////////////////////////////////////////////

# use to carry over prompts without adding a line marker while retaining color

frobulator.nul () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	color="${color::-1}"

	echo -e "${color}${marker_nul} ${value}${reset}"
}

# number line marker ///////////////////////////////////////////////////////////


# use to indicate numbered steps, directives or instructions
# number value is inserted as line marker

# usage:      frobulator.num "[number]" "[string]" "[string]" "[span character]"

# command:    frobulator.num "[number]" "[string]"
# result:     [ n ] string

# command:    frobulator.num "[number]" "[string]" "[string]"
# result:     [ n ] string ///////////////////////////////////////////////////////////// string

# command:    frobulator.num "[number]" "[string]" "[string]" "[\]"
# result:     [ n ] string \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ string

frobulator.num () {
	before="[ "
	after=" ]"

	number="${1}"

	shift

	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${before}${number}${after} ${value}"
}

# separator line marker ////////////////////////////////////////////////////////

# use to separate notices and messages from execution blocks

# note:
# no line marker

# usage:      frobulator.sep

# command:    frobulator.sep
# result:     ////////////////////////////////////////////////////////////////////////////////

frobulator.sep () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${value}"
}

# separate /////////////////////////////////////////////////////////////////////

# use to separate instructions or warnings from prompts

# note:
# set up as predefined separator

# usage:      frobulator.separate

# command:    frobulator.separate
# result:     ////////////////////////////////////////////////////////////////////////////////
#

frobulator.separate () {

	frobulator.sep
	echo
}

# script ///////////////////////////////////////////////////////////////////////

# use to mark the beginning of a script process
# derives title from script name:
# script name must be separated with '-' character as 'script-name'

# usage:      frobulator.script

# command:    frobulator.script "Setting up ${script#*-}"
# result:     [ ¬§ ] Setting up 'script' ///////////////////////////////////////////// [ name ]

frobulator.script () {
	description="${1}"

	if [[ "${script}" = *-* ]]
	then
		message="${script%-*} // ${version}"
	else
		message="${script}"
	fi

	echo

	frobulator.msg "${description}" "[ ${message} ]"
}

# type /////////////////////////////////////////////////////////////////////////

# use to emulate typing on prompts
# timeout is randomized to create human-like typing effect
# seconds must be an integer

# usage:      frobulator.type "[string]" "[seconds]"

frobulator.type () {
	string=${#1}
	seconds="${2}"

	if [ -z "${seconds}" ]
	then
		seconds=3
	fi

	for (( character=0; character<=${string}; character++ ))
	do
		decimal=$(( (RANDOM % ${seconds}) + 1 ))

		sleep="0.${decimal}"

		echo -n -e "${1:${character}:1}"

		sleep "${sleep}"
	done

	echo
}

# wait /////////////////////////////////////////////////////////////////////////

# use to mark timeout in between commands in seconds

# usage:      frobulator.timeout "[seconds]"

frobulator.timeout () {
	# timeout in seconds

	seconds="${1}"

	# set defaults

	if [ -z "${seconds}" ]
	then
		seconds="1"
	fi

	sleep "${seconds}"
}

# clear ////////////////////////////////////////////////////////////////////////

# use for script process 'paging':
# clears previous step when all checkpoint markers are met

frobulator.clear () {
	frobulator.timeout

	clear
}

# countdown ////////////////////////////////////////////////////////////////////

# use as countdown marker before next command runs:
# leaves preset time for long interaction with prompts and other long strings

# usage:      frobulator.countdown "[seconds]" "[string]" "[string]"

frobulator.countdown () {
	before="[ "
	after=" ]"

	seconds="${1}"

	shift

	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	shift

	while [ "${seconds}" -ge 0 ]
	do
		if [ "${seconds}" -eq 0 ]
		then
			ticker="-"

			echo -n -e "\r${before}${yellow}${ticker}${reset}${after} ${value}\c"

			break
		else
			echo -n -e "\r${before}${red}$((seconds--))${reset}${after} ${value}\c"
		fi

		sleep 1

	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# progress /////////////////////////////////////////////////////////////////////

# use as ticker line marker to mark process wait progress
# use after process marked to for in background

# usage:      process &
#             frobulator.progress "[string]"

frobulator.progress () {
	# catch PID of last command

	PID=$!

	spinner="‚é∫‚éª‚éº‚éΩ‚éº‚éª"

	before="[ "
	after=" ]"

	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	i=1

	while [ -d /proc/"${PID}" ]
	do
		echo -n -e "\r${before} \b${spinner:i++%${#spinner}:1}${after} ${value}\c "

		sleep 0.25
	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# bar //////////////////////////////////////////////////////////////////////////

# WIP

# use to mark process progress

frobulator.bar () {
	current="${1}"
	total="${2}"

	# catch PID of last command

	PID=$!

	seconds="0.1"

	span=80		# total characters for line

	before=8	# maximum characters for header:		'[ x ] [ '
	after=12	# maximum characters for percentage:	' ] [ xxx % ]'

	let buffer=${span}-${before}-${after}

	let ratio=(${current}*100/${total}*100)
	let percentage=${ratio}/100

	let done=(${percentage}*${buffer})/100
	let left=${buffer}-${done}

	done=$(printf "%${done}s")
	left=$(printf "%${left}s")

	# substitutions

	done="${purple}${done// //}${reset}"
	left="${yellow}${left// /-}${reset}"

	header="${marker_fwd}"
	bar=" [ ${done}${left} ] "

	# padding

	if (( ${1} >= 0 && ${1} <= 9 ))
	then
		# handle number spacing for entries 1-9

		percentage="[ ${percentage}   % ]"

	elif (( ${current} >= 10 && ${total} <= 99 ))
	then
		# handle number spacing for entries 10-99

		percentage="[ ${percentage}  % ]"
	else
		# handle number spacing for 100-999

		percentage="[ ${percentage} % ]"
	fi

	echo -n -e "\r${header}${bar}${percentage}\c"

	sleep "${seconds}"
}

# temporary ////////////////////////////////////////////////////////////////////

# use to generate temporary directory from argument or array list
# generates directory template as 'frobulator_temporary_XXXXXX'
# useful for program builds and process transfer features

# usage:      frobulator.temporary "[directory name]" | "[array name]"

frobulator.temporary () {
	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		directory="${1}"

		list=()

		list+=("${directory}")
	fi

	for directory in ${list[@]}
	do
		frobulator.add "Creating temporary directory" "[ ${directory} ]"
		echo

		temporary_directory=$(mktemp -d -t "frobulator.temporary.XXXXXX")

		frobulator_return+=("${directory}"="${temporary_directory}")
	done
}

# trap /////////////////////////////////////////////////////////////////////////

# use to cleanup temporary directory or other process driven execution
# handles exit codes and signals to ensure proper cleanup
# specify directory name as variable returned from 'eval' in frobulator.temporary

# usage:      frobulator.temporary "[directory name]" | "[array name]"
#             frobulator.trap "${directory name}"

frobulator.trap () {
	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		directory="${1}"

		list=()

		list+=("${directory}")
	fi

	for directory in ${list[@]}
	do
		trap "exit 1"					HUP INT PIPE QUIT TERM
		trap 'rm -r -f "${directory}"'	EXIT
	done
}

# directory ////////////////////////////////////////////////////////////////////

# use to generate directory from argument or array list
# "${path}" defaults to "${PWD}" when omitted

# usage:      frobulator.directory "[path]" "[directory name]" | "[array name]"

frobulator.directory () {
	if [ $# -eq 1 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${1} - array

			list=(${@:1})
		else
			file="${1}"

			list=()

			list+=("${file}")
		fi
	else
		path="${1}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	fi

	for directory in ${list[@]}
	do
		frobulator.add "Creating directory" "[ ${directory} ]"
		echo

		# create directory and set permissions

		if [ ! -d "${path}"/"${directory}" ]
		then
			mkdir -p "${path}"/"${directory}"
		fi

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${directory}"
	done

	# unset array

	list=()
}

# write ////////////////////////////////////////////////////////////////////////

# use to generate and write to file(s) from argument or array list
# appends content to file

# "${path}" defaults to "${PWD}" when omitted

# usage:      frobulator.write "[content]" "[path]" "[file]"

frobulator.write () {
	content="${1}"

	if [ $# -eq 2 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	else
		path="${2}"

		if [ -z "${path}" ]
		then
			path="${PWD}"
		fi

		if [[ -n "${#list[@]}" ]]
		then
			# ${3} - array

			list=(${@:3})
		else
			file="${3}"

			list=()

			list+=("${file}")
		fi
	fi

	if [ ! -d "${path}" ]
	then
		mkdir -p "${path}"
	fi

	for file in ${list[@]}
	do
		frobulator.add "Writing" "[ ${file} ]"
		echo

		# write to file and set permissions

		echo "${content}" >> "${path}"/"${file}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"

		# set permissions

		chmod a+rx "${path}"/"${file}"
	done

	# unset array

	list=()
}

# flag / ///////////////////////////////////////////////////////////////////////

# use to generate and write to file(s) from argument or array list
# overwrites content to file

# "${path}" defaults to "${PWD}" when omitted

# usage:      frobulator.flag "[content]" "[path]" "[file]"

frobulator.flag () {
	content="${1}"

	if [ $# -eq 2 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	else
		path="${2}"

		if [ -z "${path}" ]
		then
			path="${PWD}"
		fi

		if [[ -n "${#list[@]}" ]]
		then
			# ${3} - array

			list=(${@:3})
		else
			file="${3}"

			list=()

			list+=("${file}")
		fi
	fi

	if [ ! -d "${path}" ]
	then
		mkdir -p "${path}"
	fi

	for file in ${list[@]}
	do
		frobulator.add "Flagging" "[ ${file} ]"
		echo

		# write to file and set permissions

		echo "${content}" > "${path}"/"${file}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"

		# set permissions

		chmod a+rx "${path}"/"${file}"
	done
}

# file /////////////////////////////////////////////////////////////////////////

# use to generate file(s) from argument or array list

frobulator.file () {
	if [ $# -eq 1 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${1} - array

			list=(${@:1})
		else
			file="${1}"

			list=()

			list+=("${file}")
		fi
	else
		path="${1}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	fi

	if [ ! -d "${path}" ]
	then
		 mkdir -p "${path}"
	fi

	for file in ${list[@]}
	do
		frobulator.add "Creating" "[ ${file} ]"
		echo

		# create file and set permissions

		if [ ! -f "${path}"/"${file}" ]
		then
			touch "${path}"/"${file}"
		fi

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"
	done

	# unset array

	list=()
}

# keep /////////////////////////////////////////////////////////////////////////

# use to reverse-select file(s) for deletion from argument or array list
# keeps selected files in directory

frobulator.keep () {
	if [ $# -eq 1 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${1} - array

			list=(${@:1})
		else
			file="${1}"

			list=()

			list+=("${file}")
		fi
	else
		path="${1}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	fi

	if [ -d "${path}" ]
	then
		# enter path and parse items

		cd "${path}"

		for item in *
		do
			keep=0

			for file in ${list[@]}
			do
				# mark for keeping

				if [[ "${path}"/"$file" = "${path}"/"$item" ]]
				then
					keep=1

					frobulator.ret "Keeping" "[ ${file} ]"
					echo
				fi
			done

			# remove unmarked items

			if [[ "$keep" = 0 ]]
			then
				rm -rf "${item}"
			fi
		done
	else
		frobulator.error "Path does not exist" "[ ${path} ]"
		echo
	fi

	# unset array

	list=()
}

# delete ///////////////////////////////////////////////////////////////////////

# use to select file(s) for deletion from argument or array list
# removes selected file in directory

frobulator.delete () {
	if [ $# -eq 1 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${1} - array

			list=(${@:1})
		else
			file="${1}"

			list=()

			list+=("${file}")
		fi
	else
		path="${1}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	fi

	for file in ${list[@]}
	do
		frobulator.rem "Deleting" "[ ${file} ]"
		echo

		# remove file

		rm -r -f "${path}"/"${file}"
	done

	# unset array

	list=()
}

# copy /////////////////////////////////////////////////////////////////////////

# use to copy file(s) and/or diretories from argument or array list

frobulator.copy () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${target}" ]
	then
		mkdir -p "${target}"
	fi

	for file in ${list[@]}
	do
		frobulator.lnk "Copying" "[ ${file} ]"
		echo

		cp -r -f "${source}"/"${file}" "${target}"/"${file}"
	done

	# unset array

	list=()
}

# move /////////////////////////////////////////////////////////////////////////

# use to move file(s) and/or diretories from argument or array list

frobulator.move () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${target}" ]
	then
		mkdir -p "${target}"
	fi

	for file in ${list[@]}
	do
		if [ -z "${source}" ]
		then
			source="${PWD}"
		fi

		frobulator.lnk "Moving" "[ ${file} ]"
		echo

		mv "${source}"/"${file}" "${target}"/"${file}"
	done

	# unset array

	list=()
}

# link /////////////////////////////////////////////////////////////////////////

# use to link file(s) and/or diretories from argument or array list

frobulator.link () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${3} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${target}" ]
	then
		mkdir -p "${target}"
	fi

	for file in ${list[@]}
	do
		if [ -e "${source}"/"${file}" ]
		then
			if [ $# -eq 3 ]
			then
				file=${list[0]}
				link=${list[0]}
			fi

			if [ $# -eq 4 ]
			then
				file=${list[0]}
				link=${list[1]}
			fi

			frobulator.lnk "Linking" "[ ${file} ]"
			echo

			ln -s -f "${source}"/"${file}" "${target}"/"${link}"

			chown "${uid}":"${gid}" -R "${target}"/"${link}"
		fi
	done

	# unset array

	list=()
}

# status ///////////////////////////////////////////////////////////////////////

# use to validate http status code prior to download / upload operations

frobulator.status () {
	url="${@}"

	status_code="%{http_code}\n"

	url_status=$(curl								\
				--silent							\
				--output		"${sink}"			\
				--write-out 	"${status_code}"	\
													"${url}"
				)
}

# download /////////////////////////////////////////////////////////////////////

# use to download file(s) with url status verification from argument or array list

frobulator.download () {
	url="${1}"

	frobulator.status "${url}"

	if [[ "${url_status}" = [0145][0-9][0-9] ]]
	then
		frobulator.err "Error" "[ Status // ${url_status} ]"
		echo

	elif [[ "${url_status}" = [23][0-9][0-9] ]]
	then
		frobulator.scs "Found" "[ Status // ${url_status} ]"
		echo

		if [ $# -eq 2 ]
		then
			path="${PWD}"

			if [[ -n "${#list[@]}" ]]
			then
				# ${2} - array

				list=(${@:2})
			else
				file="${2}"

				list=()

				list+=("${file}")
			fi
		elif [ $# -eq 3 ]
		then
			path="${2}"

			if [[ -n "${#list[@]}" ]]
			then
				# ${3} - array

				list=(${@:3})
			else
				file="${3}"

				list=()

				list+=("${file}")
			fi

		elif [ $# -eq 4 ]
		then
			source_file="${2}"
			path="${3}"

			if [ -z "${path}" ]
			then
				path="${PWD}"
			fi

			if [[ -n "${#list[@]}" ]]
			then
				# ${4} - array

				list=(${@:4})
			else
				file="${4}"

				list=()

				list+=("${file}")
			fi
		else
			path="${2}"

			if [ -z "${path}" ]
			then
				path="${PWD}"
			fi

			if [[ -n "${#list[@]}" ]]
			then
				# ${3} - array

				list=(${@:3})
			else
				file="${3}"

				list=()

				list+=("${file}")
			fi
		fi

		if [ ! -d "${path}" ]
		then
			mkdir -p "${path}"
		fi

		for file in ${list[@]}
		do
			if [ $# -eq 2 ]
			then
				curl			\
					--silent	\
					--location	"${url}" > "${path}"/"${file}" &

			elif [ $# -eq 3 ]
			then
				curl			\
					--silent	\
					--location	"${url}"/"${file}" > "${path}"/"${file}" &

			elif [ $# -eq 4 ]
			then
				curl			\
					--silent	\
					--location	"${url}"/"${source_file}" > "${path}"/"${file}" &

			else
				curl			\
					--silent	\
					--location	"${url}"/"${file}" > "${path}"/"${file}" &
			fi

			frobulator.progress "Downloading" "[ '${file}' ]"
			echo

			chmod a+rx "${path}"/"${file}"
		done

		# unset array

		list=()

	else
		frobulator.err "Status unknown" "[ Status // N/A ]"
		echo
	fi
}

# put //////////////////////////////////////////////////////////////////////////

# WIP

frobulator.put () {
	type="${1}"

	curl									\
		-X PUT "${destination}/${file}"		\
		-H "Content-Type: ${type}"			\
		-d 									"${file}" &

	frobulator.progress "Uploading" "[ '${file}' ]"
	echo
}

# upload ///////////////////////////////////////////////////////////////////////

# WIP

frobulator.upload () {

	frobulator.upl "Loading..."
	echo

	frobulator.put
}

# silence //////////////////////////////////////////////////////////////////////

# use to wrap command execution and redirect all output to null sink
# provides fully silent execution

frobulator.silence () {
	command="${@}"

	"${shell}" -c "$(echo ${command})" >> "${sink}" 2>&1
}

# log //////////////////////////////////////////////////////////////////////////

# use to wrap command and redirect all output to "${script}"-"${stamp}".log file
# provides fully silent execution

frobulator.log () {
	if [ -z "${SUDO:-$HOME}" ]
	then
		log_directory="${PREFIX}"/var/log
	else
		if [ ! -d "${HOME}"/.local/var/log ]
		then
			mkdir -p "${HOME}"/.local/var/log
		fi

		log_directory="${HOME}"/.local/var/log
	fi

	if [ -z "${script}" ]
	then
		script=$(basename -- "${BASH_SOURCE[0]}")
	fi

	command="${@}"

	"${shell}" -c "$(echo ${command})" >> "${log_directory}"/"${script}"-"${stamp}".log 2>&1
}

# password /////////////////////////////////////////////////////////////////////

# use to obfuscate password input with custom mask character

frobulator.password () {
	mask_character="‚Ä¢"

	while  read -p "${mask}" -r -s -n 1 input_character
	do
		# enter / accept password

		if [[ "${input_character}" == $'\0' ]]
		then
			# break on 'NUL'

			break
		fi

		# handle backspace / delete character input

		if [[ "${input_character}" == $'\177' ]]
		then
			# remove input on 'BACKSPACE'/'DEL'

			mask=$'\b \b'
			password="${password%?}"
		else
			# set character mask

			mask="${mask_character}"

			# append user input and fomr password

			password+="${input_character}"
		fi
	done

	input="${password}"

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# input ////////////////////////////////////////////////////////////////////////

# use to capture user input

frobulator.input () {
	list=($@)

	for value in "${list[@]}"
	do
		label=${value^}
		prompt="$(echo ${label} | sed 's/_/ /'):"

		frobulator.ipt "${prompt}"

		if [[ "${value}" = *password* ]]
		then
			frobulator.password
		else
			read input
		fi

		# prevent empty input

		while true
		do
			if [ -z "${input}" ]
			then
				echo
				frobulator.err "${prompt%:} cannot be empty."
				echo

				prompt="$(echo ${label} | sed 's/_/ /'):"

				frobulator.ipt "${prompt}"

				if [[ "${value}" = *password* ]]
				then
					frobulator.password
				else
					read input
				fi
			else
				break
			fi
		done

		value=${label,}

		frobulator_return+=("${value}=${input}")

	done

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# clean ////////////////////////////////////////////////////////////////////////

# use to run package and installer post-install cleanup

frobulator.clean () {
	command_autoremove="apt-get autoremove"
	command_clean="apt-get clean"

	frobulator.log "${command_autoremove}" &

	frobulator.progress "Flushing package(s)..."
	echo

	frobulator.log "${command_clean}" &

	frobulator.progress "Cleaning..."
	echo

	# fix 'dpkg' lock and errors:
	# remove all post-install logs - prevent package configuration errors

	if [ -d "${PREFIX}"/var/lib/dpkg/info ]
	then
		rm -r -f "${PREFIX}"/var/lib/dpkg/info/*.postinst >> "${sink}" 2>&1
	fi
}

# hold /////////////////////////////////////////////////////////////////////////

# use to hold package(s) from argument or array list
# marks package(s) for version freeze

frobulator.hold () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_hold="apt-mark hold"

	frobulator.inf "Holding package(s)."
	echo

	for package in ${list[@]}
	do
		frobulator.wrn "Holding" "[ '${package}' ]"
		echo

		frobulator.log "${command_hold} ${package}" &

		frobulator.progress "Holding..."
		echo
	done

	# unset array

	list=()
}

# release //////////////////////////////////////////////////////////////////////

# use to release package(s) from argument or array list
# unmarks package(s) for version freeze

frobulator.release () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_unhold="apt-mark unhold"

	frobulator.inf "Releasing package(s)."
	echo

	for package in ${list[@]}
	do
		frobulator.wrn "Releasing" "[ '${package}' ]"
		echo

		frobulator.log "${command_unhold} ${package}" &

		frobulator.progress "Releasing..."
		echo
	done

	# unset array

	list=()
}

# failsafe /////////////////////////////////////////////////////////////////////

# use to install package(s) and update system to avoid 'ignore' or 'not found' errors
# useful as failsafe to fetch all up-to-date content before batch install

frobulator.failsafe () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_update="apt-get --assume-yes update"
	command_upgrade="apt-get --assume-yes upgrade"
	command_install="apt-get --assume-yes install"

	for package in ${list[@]}
	do
		query_command="$(command -v "${package}")"

		while [[ -z "${query_command}" ]]
		do
			frobulator.log "${command_update}"

			frobulator.log "${command_upgrade}"

			frobulator.log "${command_install} ${package}"

			frobulator.log "${command_update}"
		done
	done

	# unset array

	list=()
}

# install //////////////////////////////////////////////////////////////////////

# use to install package(s) from argument or array list

frobulator.install () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_install="apt-get --assume-yes install"

	frobulator.inf "Installing package(s)."
	echo

	for package in ${list[@]}
	do
		if [[ "${package}" = "*.deb" ]]
		then
			frobulator.msg "Local package(s) selected."
			echo

			frobulator.log "$(echo ${command_install} ${package})" &

			frobulator.progress "Installing..."
			echo
		else
			query_filter="$(apt  search "${package}" 2> "${sink}" | grep installed | cut -d '/' -f 1 | grep ^"${package}"$)"

			if [[ -z "${query_filter}" ]]
			then
				frobulator.wrn "Absent on system" "[ '${package}' ]"
				echo

				frobulator.log "$(echo ${command_install} ${package})" &

				frobulator.progress "Installing..."
				echo

				# cleanup

				frobulator.clean

			else
				frobulator.scs "Present on system" "[ '${package}' ]"
				echo

				frobulator.fwd "Continuing..."
				echo

				:
			fi
		fi
	done

	# unset array

	list=()
}

# require //////////////////////////////////////////////////////////////////////

# use to install required package(s) from argument or array list
# use to search and validate required package dependencies for operations

frobulator.require () {
	export DEBIAN_FRONTEND=noninteractive

	frobulator.failsafe apt-file

	frobulator.log "apt-file update"

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		command="${1}"

		list=()

		list+=("${command}")
	fi

	frobulator.fwd "Validating requirement(s)..."
	echo

	for command in ${list[@]}
	do
		frobulator.fwd "Probing..."
		echo

		list=()

		system_binary_directory=/usr/bin

		query_filter="$(apt-file search "${command}" | sed 's/ //' | sort -u | grep "${system_binary_directory}"/"${command}"$)"

		IFS=$'\n'

		query_filter=(${query_filter})

		IFS=''

		query_package="$(echo "${query_filter}" | cut -d ':' -f 1)"
		query_content="$(echo "${query_filter}" | cut -d ':' -f 2)"

		query_command="${system_binary_directory}"/"${command}"

		if [ "${query_command}" == "${query_content}" ] && [ "${command}" == "${query_package}" ]
		then
			frobulator.scs "Command provision found as package" "[ '${query_package}' ]"
			echo

			install_list+=("${query_package}")

		elif [ "${query_command}" == "${query_content}" ] && [ "${command}" != "${query_package}" ]
		then
			frobulator.scs "Command provision found as reverse match" "[ '${query_package}' ]"
			echo

			install_list+=("${query_package}")

		else
			query_filter="$(apt-file search "${command}" | sed 's/ //' | sort -u | grep ^"${command}")"

			IFS=$'\n'

			query_filter=(${query_filter})

			IFS=''

			for selection in ${query_filter[@]}
			do
				query_filter="${selection}"

				query_package="$(echo "${query_filter}" | cut -d ':' -f 1)"
				query_content="$(echo "${query_filter}" | cut -d ':' -f 2)"

				query_command="${command}"

				if [ "${query_command}" != "${query_content}" ] && [ "${command}" = "${query_package}" ]
				then
					frobulator.scs "Command provision found as metapackage" "[ '${query_package}' ]"
					echo

					install_list+=("${query_package}")
				fi
			done
		fi

		# install

		if [[ "${#install_list[@]}" -ge 1 ]]
		then
			frobulator.install ${install_list[@]}

			install_list=()
		else
			frobulator.err "Command provision not found" "[ '${command}' ]"
			echo

			:
		fi

		# unset array

		list=()
	done
}

# reinstall ////////////////////////////////////////////////////////////////////

# use to reinstall package(s) from argument or array list

frobulator.reinstall () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_reinstall="apt-get --assume-yes install --reinstall"

	frobulator.inf "Reinstalling package(s)."
	echo

	for package in ${list[@]}
	do
		frobulator.log "${command_reinstall} ${package}" &

		frobulator.progress "Reinstalling..."
		echo
	done

	# unset array

	list=()

	# cleanup

	frobulator.clean
}

# update ///////////////////////////////////////////////////////////////////////

# use to update system package(s)

frobulator.update () {
	export DEBIAN_FRONTEND=noninteractive

	command_update="apt-get update"

	frobulator.inf "Processing package and repository information."
	echo

	frobulator.log "${command_update}" &

	frobulator.progress "Updating..."
	echo
}

# upgrade //////////////////////////////////////////////////////////////////////

# use to upgrade system packages

frobulator.upgrade () {
	export DEBIAN_FRONTEND=noninteractive

	command_upgrade="apt-get --assume-yes dist-upgrade"

	frobulator.inf "Processing installed package(s)."
	echo

	frobulator.log "${command_upgrade}" &

	frobulator.progress "Upgrading..."
	echo
}

# purge ////////////////////////////////////////////////////////////////////////

# use to purge package(s) from argument or array list

frobulator.purge () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_purge="apt-get --assume-yes purge --autoremove"

	frobulator.inf "Purging selected package(s)."
	echo

	for package in ${list[@]}
	do
		if [[ ! -z $(apt search "${package}" 2> "${sink}" | grep -i -o installed) ]]
		then
			frobulator.wrn "Selecting" "[ '${package}' ]"
			echo

			frobulator.log "$(echo ${command_purge} ${package})" &

			frobulator.progress "Purging..."
			echo
		else
			frobulator.scs "Absent on system" "[ '${package}' ]"
			echo

			frobulator.fwd "Continuing..."
			echo

			:
		fi
	done

	# unset array

	list=()

	# cleanup

	frobulator.clean
}

# dialog ///////////////////////////////////////////////////////////////////////

# use to generate standard dialogs using desktop environement plugins:
# supports:
# gnome - zenity
# kde - kdialog

frobulator.dialog () {
	# dialog window title

	title="${script%.sh} - ${1}"

	dialog_command="${@}"

	# gtk dialog - zenity

	g_dialog () {
		zenity						\
			--file-selection		\
			--multiple				\
			--directory				\
			--separator=$'\n'		\
			--title="${title}"		"${dialog_command}"
	}

	# kde dialog - kdialog

	k_dialog () {
		kdialog						\
			--getopenfilename		\
			--multiple				\
			--separate-output		\
			--title "${title}"		"${dialog_command}"
	}

	# define dialog usage

	if [[ $(command -v zenity) ]]
	then
		dialog=$(g_dialog)

	elif [[ $(command -v kdialog) ]]
	then
		dialog=$(k_dialog)
	else
		frobulator.wrn "This utility must be run using the 'directory' option."
		echo

		frobulator.fwd "Exiting..."
		echo

		exit 1
	fi
}

# terminate ////////////////////////////////////////////////////////////////////

# use to forcefully terminate rogue processes

frobulator.terminate () {
	process_name="${1}"

	if [[ $(command -v pgrep) ]] && [[ $(command -v pkill) ]]
	then
		while [[ $(pgrep -f "${process_name}") ]]
		do
			pkill "${process_name}"
		done
	fi
}

# exit /////////////////////////////////////////////////////////////////////////

# use to exit process or program instance

frobulator.exit () {
	instance="${1}"

	frobulator.countdown 3 "Exiting" "[ ${instance} ]"

	frobulator.kill "${shell}"
}

# result ///////////////////////////////////////////////////////////////////////

# use to flag process checkpoint results such as installations and deployments

frobulator.result () {

	if [ $# -eq 1 ]
	then
		path="${PWD}"

		checkpoint="${1}"
		instance="${2}"
	else
		path="${1}"

		checkpoint="${2}"
		instance="${3}"
	fi

	if [ -f "${path}"/"${checkpoint}" ]
	then
		frobulator.scs "Setup complete" "[ ${instance} ]"
		echo
	else
		frobulator.err "Setup errors may have been encountered" "[ ${instance} ]"
		echo

		frobulator.inf "Review setup logs for details" '[ ${PREFIX}/var/log/ ]'
		echo
	fi
}

# user /////////////////////////////////////////////////////////////////////////

# use to identify 'user' name
# usefule for priviledged execution status checks

frobulator.user () {
	frobulator.msg "Current shell user name" "[ '${SUDO_USER:-$USER}' ]"
	echo

	sleep 1
}

# assess ///////////////////////////////////////////////////////////////////////

# use to assess 'superuser' status and prompt for priviledged execution
# useful for in-script dependency assessment and installation

frobulator.assess () {
	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		command="${1}"

		list=()

		list+=("${command}")
	fi

	if [[ $(id -u -n) = "root" ]]
	then
		frobulator.require ${list[@]}

		frobulator.msg "Requirement(s) installed" "[ ${script} ]"
		echo

		frobulator.inf "Restart as '${USER}' to proceed." "[ '${script}' ]"
		echo
	else
		for command in ${list[@]}
		do
			if [[ -z $(command -v "${command}") ]]
			then
				frobulator.err "Missing" "[ '${command}' ]"
				echo

				frobulator.wrn "Privilege escalation required to proceed." "[ '${script}' ]"
				echo

				frobulator.ask "Launch as 'root'?"

				read reply
				echo

				if [[ "${reply}" = [yY] ]] || [[ "${reply}" = [yY][eE][sS] ]]
				then
					frobulator.escalate
				else
					frobulator.wrn "Launch as 'root' to install requirement(s)." "[ '${script}' ]"
					echo
				fi
			fi
		done
	fi

	# unset array

	list=()
}

# escalate /////////////////////////////////////////////////////////////////////

# use to provide priviledged execution
# restarts script process as 'superuser' once the status is granted

frobulator.escalate () {
	if [[ $(id -u -n) = "root" ]]
	then
		frobulator.inf "Setting up privileged execution" "[ '${USER}' ]"
		echo

		USER="${SUDO_USER}"

		HOME=/home/"${SUDO_USER}"
	else
		frobulator.wrn "Privilege escalation granted: restarting command" "[ 'root' ]"
		echo

		if [[ -z $(command -v sudo) ]]
		then
			frobulator.require sudo
		fi

		self="${0}"
		command="${@}"

		# set superuser password prompt

		export SUDO_PROMPT="[ $(tput setaf 3)${USER}$(tput sgr 0) ] >_ ? "

		# restart as superuser

		exec sudo "${shell}" "${self}" "${command}"
		echo
	fi
}


# archive //////////////////////////////////////////////////////////////////////

# use to archive content and for backup procedures

frobulator.archive () {
	list+=(
		7zip
		bzip2
		gzip
		rar
		tar
		zip
	)

	frobulator.install ${list[@]}

	# unset array

	list=()

	file="${1}"
	extension="${2}"
	directory="${3}"

	archive="${file}.${extension}"

	if [ -z "${directory}" ]
	then
		directory="${PWD}"
	fi

	if [ ! -d "${directory}" ]
	then
		echo
		frobulator.err "Unavailable" "[ '${directory}' ]"
		echo

		exit 1
	fi

	case "${extension}"
	in
		tar.bz2|tbz2)
			tar								\
				--create					\
				--bzip						\
				--file="${archive}"			"${directory}" > "${sink}" 2>&1

				frobulator.inf "Archiving" "[ ${archive} ]"
				echo
		;;

		tar.gz|tgz)
			tar								\
				--create					\
				--gzip						\
				--file="${archive}"			"${directory}" > "${sink}" 2>&1

				frobulator.inf "Archiving" "[ ${archive} ]"
				echo
		;;

		tar)
			tar								\
				--create					\
				--file="${archive}"			"${directory}" > "${sink}" 2>&1

				frobulator.inf "Archiving" "[ ${archive} ]"
				echo
		;;

# 			bz2)
# 				bzip					\
# 					--stdout			\
# 					--keep				\
# 					--quiet				"${directory}" > "${archive}"
#
# 					frobulator.inf "Archiving" "[ ${archive} ]"
# 					echo
# 			;;

# 			gz)
# 				gzip					\
# 					--stdout			\
# 					--keep				\
# 					--quiet				"${directory}" > "${archive}"
#
# 					frobulator.inf "Archiving" "[ ${archive} ]"
# 					echo
# 			;;

		7z)
			7z a "${archive}" -o "${directory}" > "${sink}" 2>&1

				frobulator.inf "Archiving" "[ ${archive} ]"
				echo
		;;

			*.rar)
 				rar a "${archive}" "${directory}" > "${sink}" 2>&1

 					frobulator.inf "Archiving" "[ ${archive} ]"
 					echo
 			;;

		zip)
			zip								\
				-f							\
				-qq 						\
				-r "${archive}"				"${directory}"

				frobulator.inf "Archiving" "[ ${archive} ]"
				echo
		;;

		*)
			echo
			frobulator.err "Unsupported archive type" "[ '${archive}' ]"
			echo
		;;
	esac
}


# extract //////////////////////////////////////////////////////////////////////

# use to extract known archive types for script dependency or process resolution

frobulator.extract () {
	list+=(
		7z
		bunzip2
		gunzip
		tar
		unrar
		unzip
	)

	frobulator.install ${list[@]}

	# unset array

		list=()

	file="${1}"
	extension="${2}"
	directory="${3}"

	archive="${file}.${extension}"

	if [ -z "${directory}" ]
	then
		directory="${PWD}"
	fi

	if [ ! -d "${directory}" ]
	then
		mkdir -p "${directory}"
	fi

	if [ -f "${archive}" ]
	then
		case "${extension}"
		in
			*.tar.bz2|*.tbz2)
				tar								\
					--extract					\
					--bzip2						\
					--file="${archive}" 		\
					--directory="${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			tar.gz|*.tgz)
				tar								\
					--extract					\
					--gzip						\
					--file="${archive}" 		\
					--directory="${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			tar)
				tar								\
					--extract					\
					--file="${archive}" 		\
					--directory="${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo

			;;

			bz2)
				bzip							\
					--stdout					\
					--keep						\
					--quiet						\
					--decompress "${archive}"	> "${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			gz)
				gzip							\
					--stdout					\
					--keep						\
					--quiet						\
					--decompress "${archive}"	> "${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			7z)
				7z								\
					x "${archive}" 				\
					-o "${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			rar)
				unrar e "${archive}" "${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			zip)
				unzip							\
					-o							\
					-qq "${archive}"			\
					-d "${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			*)
				echo
				frobulator.err "Extraction failed" "[ '${archive}' ]"
				echo
			;;
		esac
	else
		echo
		frobulator.err "Unsupported archive type" "[ '${archive}' ]"
		echo
	fi
}
