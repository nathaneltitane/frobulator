#!/bin/bash

# dependencies /////////////////////////////////////////////////////////////////

# script ///////////////////////////////////////////////////////////////////////

# version //////////////////////////////////////////////////////////////////////

# version="08-03-2023"

# variables ////////////////////////////////////////////////////////////////////

stamp=$(date +"%m-%d-%Y-%H-%M-%S")

# defaults /////////////////////////////////////////////////////////////////////

if [ -z "${SHELL}" ]
then
	shell=/bin/bash
else
	shell="${SHELL}"
fi

# provide fallback for non 'root' assessments

self="${0}"

if [ -z "${script}" ]
then
	script="${self}"
fi

# colors ///////////////////////////////////////////////////////////////////////

if [ -z "$(command -v tput)" ]
then
	# ansi color escapes

	if [[ -t 1 ]]
	then
		# dark colors

		black=$(echo -e \\e\[30m)
		maroon=$(echo -e \\e\[31m)
		green=$(echo -e \\e\[32m)
		olive=$(echo -e \\e\[33m)
		navy=$(echo -e \\e\[34m)
		purple=$(echo -e \\e\[35m)
		teal=$(echo -e \\e\[36m)
		silver=$(echo -e \\e\[37m)

		# bright colors

		grey=$(echo -e \\e\[90m)
		red=$(echo -e \\e\[91m)
		lime=$(echo -e \\e\[92m)
		yellow=$(echo -e \\e\[93m)
		blue=$(echo -e \\e\[94m)
		fuschia=$(echo -e \\e\[95m)
		aqua=$(echo -e \\e\[96m)
		white=$(echo -e \\e\[97m)

		# reset color

		reset=$(echo -e \\e\[39m)
	fi
else
	# 'tput' colors and attributes

	if [[ -t 1 ]]
	then
		# dark colors

		black=$(tput setaf 0)
		maroon=$(tput setaf 1)
		green=$(tput setaf 2)
		olive=$(tput setaf 3)
		navy=$(tput setaf 4)
		purple=$(tput setaf 5)
		teal=$(tput setaf 6)
		silver=$(tput setaf 7)

		# bright colors

		grey=$(tput setaf 8)
		red=$(tput setaf 9)
		lime=$(tput setaf 10)
		yellow=$(tput setaf 11)
		blue=$(tput setaf 12)
		fuschia=$(tput setaf 13)
		aqua=$(tput setaf 14)
		white=$(tput setaf 15)

		# define formatting

		bold=$(tput bold)
		underline_start=$(tput smul)
		underline_stop=$(tput rmul)
		reverse=$(tput rev)
		blink=$(tput blink)
		invisible=$(tput invis)
		standout_start=$(tput smso)
		standout_stop=$(tput rmso)

		# reset all attributes

		reset=$(tput sgr 0)

		# 'tput' terminal control

		# full description of terminal

		terminal_info=$(tput longname)

		# number of lines in terminal
		terminal_height=$(tput lines)

		# number of columns in terminal

		terminal_width=$(tput cols)

		# number of colors available

		terminal_colors=$(tput colors)

		# save cursor position of terminal

		terminal_save_cursor=$(tput sc)

		# restore cursor position of terminal

		terminal_restore_cursor=$(tput rc)

		# move cursor to upper left corner (0,0) - equivalent: 'tput cup 0 0'

		terminal_home_cursor=$(tput home)

		# move cursor to position (row, column)

		terminal_move_cursor=$(tput cup ${tput_row} ${tput_col})

		# move cursor down 1 row

		terminal_cursor_down=$(tput cud1)

		# move cursor up 1 row

		terminal_cursor_up=$(tput cuu1)

		# set cursor to invisible state

		terminal_cursor_hide=$(tput civis)

		# set cursor to normal state

		terminal_cursor_show=$(tput cnorm)

		# save screen contents

		terminal_save_screen=$(tput smcup)

		# restore screen contents

		terminal_restore_screen=$(tput rmcup)

		# clear from cursor to end of line - left

		terminal_clear_right=$(tput el1)

		# clear from cursor to beginning of line - right

		terminal_clear_left=$(tput el)

		# clear from cursor to end of the screen - down

		terminal_clear_down=$(tput ed)

		# clear entire screen and home cursor (0,0) - all

		terminal_clear_all=$(tput clear)
	fi
fi

# markers //////////////////////////////////////////////////////////////////////

marker_top='[ â–³ ]'
marker_bot='[ â–½ ]'

marker_fwd='[ > ]'
marker_rev='[ < ]'
marker_stp='[ / ]'

marker_add='[ + ]'
marker_rem='[ - ]'

marker_ret='[ â— ]'
marker_rel='[ â—‹ ]'

marker_ask='[ ? ]'
marker_inf='[ i ]'
marker_ipt='[ # ]'
marker_msg='[ Â¤ ]'
marker_wrn='[ ! ]'
marker_usr='[ ~ ]'

marker_yes='[ - ]'
marker_not='[ ð„‚ ]'

marker_nul='     '

# prompt ///////////////////////////////////////////////////////////////////////

frobulator.prompt () {
	# initialize string return array

	frobulator_string=()

	begin="${1}"
	end="${2}"

	# provide fallback for line character count

	if [ -z "${count}" ]
	then
		count=80
	fi

	# set span width

	if [ ${#begin} -le "${count}" ]
	then
		span="--------------------------------------------------------------------------------"
	else
		span=""
	fi

	# parse arguments

	# 0 argument - full dash line

	if [ $# -ge 0 ]
	then
		span_character="/"
	fi

	# 1 argument - pad to end of line

	if [ $# -eq 1 ]
	then
		span_character="/"
	fi

	# 3 arguments - replace span character with argument 3

	if [ $# -eq 3 ]
	then
		span_character="${3}"

		if [ ${#span_character} -gt 1 ]
		then
			count=$((${count} / ${#span_character}))
		fi
	fi

	# 2+ arguments - reduce span by 6 characters:
	# compensate for line marker + space

	if [ $# -ge 2 ]
	then
		span=${span::-6}
	fi

	# 2+ arguments - append space to 'begin' value

	if [ $# -ge 2 ]
	then
		begin="${begin} "
	fi

	# 2+ arguments - prepend space to 'end' value

	if [ $# -ge 2 ]
	then
		end=" ${end}"
	fi

	# fold paragraph if character count is above 80
	# indent second line onward (6 spaces) to match line marker

	if [ $# -eq 1 ] && [ "${#begin}" -ge "${count}" ]
	then
		begin=$(echo "${begin}" | fold -s -w "${count}" | sed -e '2,$s/^/      /g')
	fi

	# substitute span character

	span="${span//-/$span_character}"

	# print first argument

	span_begin=$(echo -n -e "${begin}")

	# print other arguments as fixed width prompt if present:
	# calculate span width - remove 6 characters for prompt header

	span_count=$(( ${#span} - ${#begin} - ${#end} ))

	# set new padding width ///////////////////////////////////////// # FIX ME #

	if [ ${#begin} -le "${count}" ]
	then
		span=${span:0:$span_count}
	else
		span=""
	fi

	# /////////////////////////////////////////////////////////////// # FIX ME #

	span_middle="${span}"

	span_end=$(echo -e "${end}")

	# populate array at end to avoid integrating spaces

	if [ $# -ge 0 ]
	then
		frobulator_string=("${span_begin}""${span_middle}""${span_end}")
	fi

	if [ $# -eq 1 ]
	then
		frobulator_string=("${span_begin}")
	fi

	if [ $# -ge 2 ]
	then
		frobulator_string=("${span_begin}""${span_middle}""${span_end}")
	fi

	if [ $# -eq 3 ]
	then
		frobulator_string=("${span_begin}""${span_middle}""${span_end}")
	fi
}

# highlights ///////////////////////////////////////////////////////////////////

# colored string highlights with built-in prompt arguments and line padding
#
# usage:      frobulator.[color] "[string]" "[string]" "[span character]"
#
# command:    frobulator.[color] "[string]"
# result:     string
#
# command:    frobulator.[color] "[string]" "[string]"
# result:     string ///////////////////////////////////////////////////////////// string
#
# command:    frobulator.[color] "[string]" "[string]" "[\]"
# result:     string \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ string

# 00 - black string highlight

frobulator.black () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${black}${value}${reset}"
}

# 01 - maroon string highlight

frobulator.maroon () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${maroon}${value}${reset}"
}

# 02 - green string highlight

frobulator.green () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${green}${value}${reset}"
}

# 03 - olive string highlight

frobulator.olive () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${olive}${value}${reset}"
}

# 04 - navy string highlight

frobulator.navy () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${navy}${value}${reset}"
}

# 05 - purple string highlight

frobulator.purple () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${purple}${value}${reset}"
}

# 06 - teal string highlight

frobulator.teal () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${teal}${value}${reset}"
}

# 07 - silver string highlight

frobulator.silver () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${silver}${value}${reset}"
}

# 08 - grey string highlight

frobulator.grey () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${grey}${value}${reset}"
}

# 09 - red string highlight

frobulator.red () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${red}${value}${reset}"
}

# 10 - lime string highlight

frobulator.lime () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${lime}${value}${reset}"
}

# 11 - yellow string highlight

frobulator.yellow () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${yellow}${value}${reset}"
}

# 12 - blue string highlight

frobulator.blue () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${blue}${value}${reset}"
}

# 13 - fuschia string highlight

frobulator.fuschia () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${fuschia}${value}${reset}"
}

# 14 - aqua string highlight

frobulator.aqua () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${aqua}${value}${reset}"
}

# 15 - white string highlight

frobulator.white () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${white}${value}${reset}"
}

# prompt marking /////////////////////////////////////////////////////////////

# colored string highlights with built-in prompt arguments, line padding and line markers

# usage:      frobulator.[color] "[string]" "[string]" "[span character]"

# command:    frobulator.[color] "[string]"
# result:     string

# command:    frobulator.[color] "[string]" "[string]"
# result:     string ///////////////////////////////////////////////////////////// string

# command:    frobulator.[color] "[string]" "[string]" "[\]"
# result:     string \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ string

# line markers:

# top [ â–³ ]
# bot [ â–½ ]

# fwd [ > ]
# rev [ < ]
# stp [ / ]

# add [ + ]
# rem [ - ]

# ret [ â— ]
# rel [ â—‹ ]

# ask [ ? ]
# inf [ i ]
# ipt [ # ]
# msg [ Â¤ ]
# wrn [ ! ]
# usr [ ~ ]

# yes [ - ]
# not [ ð„‚ ]

# nul '     '

# information line marker

frobulator.inf () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${magenta}${marker_inf} ${value}${reset}"

	color=($_)
}

# message line marker

frobulator.msg () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${blue}${marker_msg} ${value}${reset}"

	color=($_)
}

# information line marker

frobulator.wrn () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${yellow}${marker_wrn} ${value}${reset}"

	color=($_)
}

# add line marker

frobulator.add () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${magenta}${marker_add} ${value}${reset}"

	color=($_)
}

# remove line marker

frobulator.rem () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${red}${marker_rem} ${value}${reset}"

	color=($_)
}

# retain line marker

frobulator.ret () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${cyan}${marker_ret} ${value}${reset}"

	color=($_)
}

# release line marker

frobulator.rel () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${blue}${marker_rel} ${value}${reset}"

	color=($_)
}

# forward line marker

frobulator.fwd () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${grey}${marker_fwd} ${value}${reset}"

	color=($_)
}

# reverse line marker

frobulator.rev () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${grey}${marker_rev} ${value}${reset}"

	color=($_)
}

# stop line marker

frobulator.stp () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${grey}${marker_stp} ${value}${reset}"

	color=($_)
}

# download line marker

frobulator.dwl () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${magenta}${marker_bot} ${value}${reset}"

	color=($_)
}

# upload line marker

frobulator.upl () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${magenta}${marker_top} ${value}${reset}"

	color=($_)
}

# link line marker

frobulator.lnk () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${magenta}${marker_stp} ${value}${reset}"

	color=($_)
}

# success line marker

frobulator.scs () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${green}${marker_yes} ${value}${reset}"

	color=($_)
}

# error line marker

frobulator.err () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${red}${marker_not} ${value}${reset}"

	color=($_)
}

# insert line marker

frobulator.ins () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${magenta}${marker_ipt} ${value}${reset}"

	color=($_)
}

# user input prompts ///////////////////////////////////////////////////////////

# use for questions, input, user input dependant inquiries

# note:
# use 'echo -n -e' to prevent adding new line after prompt:
# keeps user input beside prompt
# also includes space after value to separate input

# ask line marker

frobulator.ask () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -n -e "${magenta}${marker_ask} ${value} ${reset}"

	color=($_)
}

# input line marker

frobulator.ipt () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -n -e "${magenta}${marker_add} ${value} ${reset}"

	color=($_)
}

# user line marker

frobulator.usr () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -n -e "${magenta}${marker_usr} ${value} ${reset}"

	color=($_)
}

# null /////////////////////////////////////////////////////////////////////////

# use to carry over prompts without adding a line marker while retaining color

frobulator.nul () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	color="${color::-1}"

	echo -e "${color}${marker_nul} ${value}${reset}"

}

# numbering ////////////////////////////////////////////////////////////////////

# use to indicate numbered steps, directives or instructions
# number value is inserted as line marker

# usage:      frobulator.num "[number]" "[string]" "[string]" "[span character]"

# command:    frobulator.num "[number]" "[string]"
# result:     [ n ] string

# command:    frobulator.num "[number]" "[string]" "[string]"
# result:     [ n ] string ///////////////////////////////////////////////////////////// string

# command:    frobulator.num "[number]" "[string]" "[string]" "[\]"
# result:     [ n ] string \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ string

frobulator.num () {
	before="[ "
	after=" ]"

	number="${1}"

	shift

	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${before}${number}${after} ${value}"
}

# separator ////////////////////////////////////////////////////////////////////

# use to separate notices and messages from execution blocks

# note:
# no line marker

# usage:      frobulator.sep

# command:    frobulator.sep
# result:     ////////////////////////////////////////////////////////////////////////////////

frobulator.sep () {
	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	echo -e "${value}"
}

# separate /////////////////////////////////////////////////////////////////////

# use to separate instructions or warnings from prompts

# note:
# set up as predefined separator

# usage:      frobulator.separate

# command:    frobulator.separate
# result:     ////////////////////////////////////////////////////////////////////////////////
#

frobulator.separate () {

	frobulator.sep
	echo
}

# script ///////////////////////////////////////////////////////////////////////

# use to mark the beginning of a script process
# derives title from script name:
# script name must be separated with '-' character as 'script-name'

# usage:      frobulator.script

# command:    frobulator.script "Setting up ${script#*-}"
# result:     [ Â¤ ] Setting up 'script' ///////////////////////////////////////////// [ name ]

frobulator.script () {
	description="${1}"

	if [[ "${script}" = *-* ]]
	then
		message="${script%-*} // ${version}"
	else
		message="${script}"
	fi

	echo

	frobulator.msg "${description}" "[ ${message} ]"
}

# type /////////////////////////////////////////////////////////////////////////

# use to emulate typing on prompts
#timeout is randomized to create human-like typing effect

# usage:      frobulator.type "[string]" "[seconds]"

frobulator.type () {
	string=${#1}
	seconds="${2}"

	if [ -z "${seconds}" ]
	then
		seconds=3
	fi

	for (( character=0; character<=${string}; character++ ))
	do
		decimal=$(( (RANDOM % ${seconds}) + 1 ))

		sleep="0.${decimal}"

		echo -n -e "${1:${character}:1}"

		sleep "${sleep}"
	done

	echo
}

# wait /////////////////////////////////////////////////////////////////////////

# use to mark timeout in between commands in seconds

# usage:      frobulator.timeout "[seconds]"

frobulator.timeout () {
	# timeout in seconds

	seconds="${1}"

	# set defaults

	if [ -z "${seconds}" ]
	then
		seconds="1"
	fi

	sleep "${seconds}"
}

# clear ////////////////////////////////////////////////////////////////////////

# use for script process 'paging':
# clears previous step when all checkpoint markers are met

frobulator.clear () {
	frobulator.timeout

	clear
}

# countdown ////////////////////////////////////////////////////////////////////

# use as countdown marker before next command runs:
# leaves preset time for long interaction with prompts and other long strings

# usage:      frobulator.countdown "[seconds]" "[string]" "[string]"

frobulator.countdown () {
	before="[ "
	after=" ]"

	seconds="${1}"

	shift

	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	shift

	while [ "${seconds}" -ge 0 ]
	do
		if [ "${seconds}" -eq 0 ]
		then
			ticker="-"

			echo -n -e "\r${before}${yellow}${ticker}${reset}${after} ${value}\c"

			break
		else
			echo -n -e "\r${before}${red}$((seconds--))${reset}${after} ${value}\c"
		fi

		sleep 1

	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# progress /////////////////////////////////////////////////////////////////////

# use as ticker line marker to mark process wait progress
# use after process marked to for in background

# usage:      process &
#             frobulator.progress "[string]"

frobulator.progress () {
	# catch PID of last command

	PID=$!

	spinner="âŽºâŽ»âŽ¼âŽ½âŽ¼âŽ»"

	before="[ "
	after=" ]"

	frobulator.prompt "${@}"
	value="${frobulator_string[@]}"

	i=1

	while [ -d /proc/"${PID}" ]
	do
		echo -n -e "\r${before} \b${spinner:i++%${#spinner}:1}${after} ${value}\c "

		sleep 0.25
	done

	# normalize line spacing:
	# additional 'echo' required due to carriage return

	echo
}

# bar //////////////////////////////////////////////////////////////////////////

# WIP

# use to mark process progress

frobulator.bar () {
	# catch PID of last command

	PID=$!

	current="${1}"
	total="${2}"

	seconds="0.1"

	span=80		# total characters for line
	before=8	# maximum characters for header:		'[ x ] [ '
	after=12	# maximum characters for percentage:	' ] [ xxx % ]'

	let buffer=${span}-${before}-${after}

	let ratio=(${current}*100/${total}*100)
	let percentage=${ratio}/100

	let done=(${percentage}*${buffer})/100
	let left=${buffer}-${done}

	done=$(printf "%${done}s")
	left=$(printf "%${left}s")

	# substitutions

	done="${magenta}${done// //}${reset}"
	left="${yellow}${left// /-}${reset}"

	header="${marker_fwd}"
	bar=" [ ${done}${left} ] "

	# padding

	if (( ${1} >= 0 && ${1} <= 9 ))
	then
		# handle number spacing for entries 1-9

		percentage="[ ${percentage}   % ]"

	elif (( ${current} >= 10 && ${total} <= 99 ))
	then
		# handle number spacing for entries 10-99

		percentage="[ ${percentage}  % ]"
	else
		# handle number spacing for 100-999

		percentage="[ ${percentage} % ]"
	fi

	echo -n -e "\r${header}${bar}${percentage}\c"

	sleep "${seconds}"
}

# temporary ////////////////////////////////////////////////////////////////////

# use to generate temporary directory from argument or array list
# generates directory template as 'frobulator_temporary_XXXXXX'
# useful for program builds and process transfer features

# usage:      frobulator.temporary "[directory name]" | "[array name]"

frobulator.temporary () {
	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		directory="${1}"

		list=()

		list+=("${directory}")
	fi

	for directory in ${list[@]}
	do
		frobulator.add "Creating temporary directory" "[ ${directory} ]"
		echo

		temporary_directory=$(mktemp -d -t "frobulator.temporary.XXXXXX")

		frobulator_return+=("${directory}"="${temporary_directory}")
	done
}

# trap /////////////////////////////////////////////////////////////////////////

# use to cleanup temporary directory or other process driven execution
# handles exit codes and signals to ensure proper cleanup
# specify directory name as variable returned from 'eval' in frobulator.temporary

# usage:      frobulator.temporary "[directory name]" | "[array name]"
#             frobulator.trap "${directory name}"

frobulator.trap () {
	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		directory="${1}"

		list=()

		list+=("${directory}")
	fi

	for directory in ${list[@]}
	do
		trap "exit 1"					HUP INT PIPE QUIT TERM
		trap 'rm -r -f "${directory}"'	EXIT
	done
}

# directory ////////////////////////////////////////////////////////////////////

# use to generate directory from argument or array list
# "${path}" defaults to "${PWD}" when omitted

# usage:      frobulator.directory "[path]" "[directory name]" | "[array name]"

frobulator.directory () {
	if [ $# -eq 1 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${1} - array

			list=(${@:1})
		else
			file="${1}"

			list=()

			list+=("${file}")
		fi
	else
		path="${1}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	fi

	for directory in ${list[@]}
	do
		frobulator.add "Creating directory" "[ ${directory} ]"
		echo

		# create directory and set permissions

		if [ ! -d "${path}"/"${directory}" ]
		then
			mkdir -p "${path}"/"${directory}"
		fi

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${directory}"
	done

	# unset array

	list=()
}

# write ////////////////////////////////////////////////////////////////////////

# use to generate and write to file(s) from argument or array list
# appends content to file

# "${path}" defaults to "${PWD}" when omitted

# usage:      frobulator.write "[content]" "[path]" "[file]"

frobulator.write () {
	content="${1}"

	if [ $# -eq 2 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	else
		path="${2}"

		if [ -z "${path}" ]
		then
			path="${PWD}"
		fi

		if [[ -n "${#list[@]}" ]]
		then
			# ${3} - array

			list=(${@:3})
		else
			file="${3}"

			list=()

			list+=("${file}")
		fi
	fi

	if [ ! -d "${path}" ]
	then
		mkdir -p "${path}"
	fi

	for file in ${list[@]}
	do
		frobulator.add "Writing" "[ ${file} ]"
		echo

		# write to file and set permissions

		echo "${content}" >> "${path}"/"${file}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"

		# set permissions

		chmod a+rx "${path}"/"${file}"
	done

	# unset array

	list=()
}

# flag / ///////////////////////////////////////////////////////////////////////

# use to generate and write to file(s) from argument or array list
# overwrites content to file

# "${path}" defaults to "${PWD}" when omitted

# usage:      frobulator.flag "[content]" "[path]" "[file]"

frobulator.flag () {
	content="${1}"

	if [ $# -eq 2 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	else
		path="${2}"

		if [ -z "${path}" ]
		then
			path="${PWD}"
		fi

		if [[ -n "${#list[@]}" ]]
		then
			# ${3} - array

			list=(${@:3})
		else
			file="${3}"

			list=()

			list+=("${file}")
		fi
	fi

	if [ ! -d "${path}" ]
	then
		mkdir -p "${path}"
	fi

	for file in ${list[@]}
	do
		frobulator.add "Flagging" "[ ${file} ]"
		echo

		# write to file and set permissions

		echo "${content}" > "${path}"/"${file}"

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"

		# set permissions

		chmod a+rx "${path}"/"${file}"
	done
}

# file /////////////////////////////////////////////////////////////////////////

# use to generate file(s) from argument or array list

frobulator.file () {
	if [ $# -eq 1 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${1} - array

			list=(${@:1})
		else
			file="${1}"

			list=()

			list+=("${file}")
		fi
	else
		path="${1}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	fi

	if [ ! -d "${path}" ]
	then
		 mkdir -p "${path}"
	fi

	for file in ${list[@]}
	do
		frobulator.add "Creating" "[ ${file} ]"
		echo

		# create file and set permissions

		if [ ! -f "${path}"/"${file}" ]
		then
			touch "${path}"/"${file}"
		fi

		# set ownership

		chown "${uid}":"${gid}" -R "${path}"/"${file}"
	done

	# unset array

	list=()
}

# keep /////////////////////////////////////////////////////////////////////////

# use to reverse-select file(s) for deletion from argument or array list
# keeps selected files in directory

frobulator.keep () {
	if [ $# -eq 1 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${1} - array

			list=(${@:1})
		else
			file="${1}"

			list=()

			list+=("${file}")
		fi
	else
		path="${1}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	fi

	cd "${path}" || exit 1

	for item in *
	do
		keep=0

		for file in ${list[@]}
		do
			# mark for keeping

			if [[ "${path}"/"$file" = "${path}"/"$item" ]]
			then
				keep=1

				frobulator.ret "Keeping" "[ ${file} ]"
				echo
			fi
		done

		# remove unmarked items

		if [[ "$keep" = 0 ]]
		then
			rm -rf "${item}"
		fi
	done

	# unset array

	list=()
}

# delete ///////////////////////////////////////////////////////////////////////

# use to delete file(s) from argument or array list
# removes selected file in directory

frobulator.delete () {
	if [ $# -eq 1 ]
	then
		path="${PWD}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${1} - array

			list=(${@:1})
		else
			file="${1}"

			list=()

			list+=("${file}")
		fi
	else
		path="${1}"

		if [[ -n "${#list[@]}" ]]
		then
			# ${2} - array

			list=(${@:2})
		else
			file="${2}"

			list=()

			list+=("${file}")
		fi
	fi

	for file in ${list[@]}
	do
		frobulator.rem "Deleting" "[ ${file} ]"
		echo

		# remove file

		rm -r -f "${path}"/"${file}"
	done

	# unset array

	list=()
}

# copy /////////////////////////////////////////////////////////////////////////

# use to copy file(s) and/or diretories from argument or array list

frobulator.copy () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${target}" ]
	then
		mkdir -p "${target}"
	fi

	for file in ${list[@]}
	do
		frobulator.lnk "Copying" "[ ${file} ]"
		echo

		cp -r -f "${source}"/"${file}" "${target}"/"${file}"
	done

	# unset array

	list=()
}

# move /////////////////////////////////////////////////////////////////////////

# use to move file(s) and/or diretories from argument or array list

frobulator.move () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${2} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${target}" ]
	then
		mkdir -p "${target}"
	fi

	for file in ${list[@]}
	do
		if [ -z "${source}" ]
		then
			source="${PWD}"
		fi

		frobulator.lnk "Moving" "[ ${file} ]"
		echo

		mv "${source}"/"${file}" "${target}"/"${file}"
	done

	# unset array

	list=()
}

# link /////////////////////////////////////////////////////////////////////////

# use to link file(s) and/or diretories from argument or array list

frobulator.link () {
	source="${1}"
	target="${2}"

	if [[ -n "${#list[@]}" ]]
	then
		# ${3} - array

		list=(${@:3})
	else
		file="${3}"

		list=()

		list+=("${file}")
	fi

	if [ ! -d "${target}" ]
	then
		mkdir -p "${target}"
	fi

	for file in ${list[@]}
	do
		if [ -e "${source}"/"${file}" ]
		then
			if [ $# -eq 3 ]
			then
				file=${list[0]}
				link=${list[0]}
			fi

			if [ $# -eq 4 ]
			then
				file=${list[0]}
				link=${list[1]}
			fi

			frobulator.lnk "Linking" "[ ${file} ]"
			echo

			ln -s -f "${source}"/"${file}" "${target}"/"${link}"

			chown "${uid}":"${gid}" -R "${target}"/"${link}"
		fi
	done

	# unset array

	list=()
}

# download /////////////////////////////////////////////////////////////////////

# use to download file(s) with url status verification from argument or array list

frobulator.download () {

source="${1}"

	status_code="%{http_code}\n"

	url_status=$(curl								\
				--silent							\
				--output		/dev/null			\
				--write-out 	"${status_code}"	\
													"${source}"
				)

	if [[ "${url_status}" = [0145][0-9][0-9] ]]
	then
		frobulator.err "Error" "[ Status // ${url_status} ]"
		echo

	elif [[ "${url_status}" = [23][0-9][0-9] ]]
	then
		frobulator.scs "Found" "[ Status // ${url_status} ]"
		echo

		if [ $# -eq 2 ]
		then
			path="${PWD}"

			if [[ -n "${#list[@]}" ]]
			then
				# ${2} - array

				list=(${@:2})
			else
				file="${2}"

				list=()

				list+=("${file}")
			fi
		elif [ $# -eq 3 ]
		then
			path="${2}"

			if [[ -n "${#list[@]}" ]]
			then
				# ${3} - array

				list=(${@:3})
			else
				file="${3}"

				list=()

				list+=("${file}")
			fi

		elif [ $# -eq 4 ]
		then
			source_file="${2}"
			path="${3}"

			if [ -z "${path}" ]
			then
				path="${PWD}"
			fi

			if [[ -n "${#list[@]}" ]]
			then
				# ${4} - array

				list=(${@:4})
			else
				file="${4}"

				list=()

				list+=("${file}")
			fi
		else
			path="${2}"

			if [ -z "${path}" ]
			then
				path="${PWD}"
			fi

			if [[ -n "${#list[@]}" ]]
			then
				# ${3} - array

				list=(${@:3})
			else
				file="${3}"

				list=()

				list+=("${file}")
			fi
		fi

		if [ ! -d "${path}" ]
		then
			mkdir -p "${path}"
		fi

		for file in ${list[@]}
		do
			if [ $# -eq 2 ]
			then
				curl			\
					--silent	\
					--location	"${source}" > "${path}"/"${file}" &

			elif [ $# -eq 3 ]
			then
				curl			\
					--silent	\
					--location	"${source}"  > "${path}"/"${file}" &

			elif [ $# -eq 4 ]
			then
				curl			\
					--silent	\
					--location	"${source}"/"${source_file}"  > "${path}"/"${file}" &

			else
				curl			\
					--silent	\
					--location	"${source}"/"${file}" > "${path}"/"${file}" &
			fi

			frobulator.progress "Downloading" "[ ${file} ]"
			echo

			chmod a+rx "${path}"/"${file}"
		done

		# unset array

		list=()

	else
		frobulator.err "Status unknown"
		echo
	fi
}

# put //////////////////////////////////////////////////////////////////////////

# WIP

frobulator.put () {
	type="${1}"

	curl									\
		-X POST "${destination}/${file}"	\
		-H "Content-Type: ${type}"			\
		-d 									"${file}" &

	frobulator.progress "Uploading" "[ ${file} ]"
	echo
}

# upload ///////////////////////////////////////////////////////////////////////

# WIP

frobulator.upload () {

	frobulator.upl "Loading..."
	echo

	frobulator.put
}

# silence //////////////////////////////////////////////////////////////////////

# use to wrap command execution and redirect all output to null sink
# provides fully silent execution

frobulator.silence () {
	command="${@}"

	"${shell}" -c "$(echo ${command})" >> /dev/null 2>&1
}

# log //////////////////////////////////////////////////////////////////////////

# use to wrap command and redirect all output to "${script}"-"${stamp}".log file
# provides fully silent execution

frobulator.log () {
	if [ -z "${SUDO:-$HOME}" ]
	then
		log_directory="${PREFIX}"/var/log
	else
		if [ ! -d "${HOME}"/.local/var/log ]
		then
			mkdir -p "${HOME}"/.local/var/log
		fi

		log_directory="${HOME}"/.local/var/log
	fi

	if [ -z "${script}" ]
	then
		script=$(basename -- "${BASH_SOURCE[0]}")
	fi

	command="${@}"

	"${shell}" -c "$(echo ${command})" >> "${log_directory}"/"${script}"-"${stamp}".log 2>&1
}

# password /////////////////////////////////////////////////////////////////////

# use to obfuscate password input with custom mask character

frobulator.password () {
	mask_character="â€¢"

	while  read -p "${mask}" -r -s -n 1 input_character
	do
		# enter / accept password

		if [[ "${input_character}" == $'\0' ]]
		then
			# break on 'NUL'

			break
		fi

		# handle backspace / delete character input

		if [[ "${input_character}" == $'\177' ]]
		then
			# remove input on 'BACKSPACE'/'DEL'

			mask=$'\b \b'
			password="${password%?}"
		else
			# set character mask

			mask="${mask_character}"

			# append user input and fomr password

			password+="${input_character}"
		fi
	done

	input="${password}"

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# input ////////////////////////////////////////////////////////////////////////

# use to capture user input

frobulator.input () {
	list=($@)

	for value in "${list[@]}"
	do
		label=${value^}
		prompt="$(echo ${label} | sed 's/_/ /'):"

		frobulator.ipt "${prompt}"

		if [[ "${value}" = *password* ]]
		then
			frobulator.password
		else
			read input
		fi

		# prevent empty input

		while true
		do
			if [ -z "${input}" ]
			then
				echo
				frobulator.err "${prompt%:} cannot be empty."
				echo

				prompt="$(echo ${label} | sed 's/_/ /'):"

				frobulator.ipt "${prompt}"

				if [[ "${value}" = *password* ]]
				then
					frobulator.password
				else
					read input
				fi
			else
				break
			fi
		done

		value=${label,}

		frobulator_return+=("${value}=${input}")

	done

	# normalize line spacing:
	# additional 'echo' required due to 'read'

	echo
}

# clean ////////////////////////////////////////////////////////////////////////

# use to run package and installer post-install cleanup

frobulator.clean () {
	command_autoremove="apt-get autoremove"
	command_clean="apt-get clean"

	frobulator.log "${command_autoremove}" &

	frobulator.progress "Flushing package(s)..."
	echo

	frobulator.log "${command_clean}" &

	frobulator.progress "Cleaning..."
	echo

	# fix 'dpkg' lock and errors:
	# remove all post-install logs - prevent package configuration errors

	if [ -d "${PREFIX}"/var/lib/dpkg/info ]
	then
		rm -r -f "${PREFIX}"/var/lib/dpkg/info/*.postinst >> /dev/null 2>&1
	fi
}

# hold /////////////////////////////////////////////////////////////////////////

# use to hold package(s) from argument or array list
# marks package(s) for version freeze

frobulator.hold () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_hold="apt-mark hold"

	frobulator.inf "Holding package(s)."
	echo

	for package in ${list[@]}
	do
		frobulator.wrn "Holding" "[ '${package}' ]"
		echo

		frobulator.log "${command_hold} ${package}" &

		frobulator.progress "Holding..."
		echo
	done

	# unset array

	list=()
}

# release //////////////////////////////////////////////////////////////////////

# use to release package(s) from argument or array list
# unmarks package(s) for version freeze

frobulator.release () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_unhold="apt-mark unhold"

	frobulator.inf "Releasing package(s)."
	echo

	for package in ${list[@]}
	do
		frobulator.wrn "Releasing" "[ '${package}' ]"
		echo

		frobulator.log "${command_unhold} ${package}" &

		frobulator.progress "Releasing..."
		echo
	done

	# unset array

	list=()
}

# failsafe /////////////////////////////////////////////////////////////////////

# use to install package(s) and update system to avoid 'ignore' or 'not found' errors
# useful as failsafe to fetch all up-to-date content before batch install

frobulator.failsafe () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_update="apt-get --assume-yes update"
	command_upgrade="apt-get --assume-yes upgrade"
	command_install="apt-get --assume-yes install"

	for package in ${list[@]}
	do
		query_command="$(command -v "${package}")"

		while [[ -z "${query_command}" ]]
		do
			frobulator.log "${command_update}"

			frobulator.log "${command_upgrade}"

			frobulator.log "${command_install} ${package}"

			frobulator.log "${command_update}"
		done
	done

	# unset array

	list=()
}

# install //////////////////////////////////////////////////////////////////////

# use to install package(s) from argument or array list

frobulator.install () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_install="apt-get --assume-yes install"

	frobulator.inf "Installing package(s)."
	echo

	for package in ${list[@]}
	do
		if [[ "${package}" = "*.deb" ]]
		then
			frobulator.msg "Local package(s) selected."
			echo

			frobulator.log "$(echo ${command_install} ${package})" &

			frobulator.progress "Installing..."
			echo
		else
			query_filter="$(apt  search "${package}" 2> /dev/null | grep installed | cut -d '/' -f 1 | grep ^"${package}"$)"

			if [[ -z "${query_filter}" ]]
			then
				frobulator.wrn "Absent on system" "[ '${package}' ]"
				echo

				frobulator.log "$(echo ${command_install} ${package})" &

				frobulator.progress "Installing..."
				echo

				# cleanup

				frobulator.clean

			else
				frobulator.scs "Present on system" "[ '${package}' ]"
				echo

				frobulator.fwd "Continuing..."
				echo

				:
			fi
		fi
	done

	# unset array

	list=()
}

# require //////////////////////////////////////////////////////////////////////

# use to install required package(s) from argument or array list
# use to search and validate required package dependencies for operations

frobulator.require () {
	export DEBIAN_FRONTEND=noninteractive

	frobulator.failsafe apt-file

	frobulator.log "apt-file update"

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		command="${1}"

		list=()

		list+=("${command}")
	fi

	frobulator.fwd "Validating requirement(s)..."
	echo

	for command in ${list[@]}
	do
		frobulator.fwd "Probing..."
		echo

		list=()

		system_binary_directory=/usr/bin

		query_filter="$(apt-file search "${command}" | sed 's/ //' | sort -u | grep "${system_binary_directory}"/"${command}"$)"

		IFS=$'\n'

		query_filter=(${query_filter})

		IFS=''

		query_package="$(echo "${query_filter}" | cut -d ':' -f 1)"
		query_content="$(echo "${query_filter}" | cut -d ':' -f 2)"

		query_command="${system_binary_directory}"/"${command}"

		if [ "${query_command}" == "${query_content}" ] && [ "${command}" == "${query_package}" ]
		then
			frobulator.scs "Command provision found as package" "[ '${query_package}' ]"
			echo

			install_list+=("${query_package}")

		elif [ "${query_command}" == "${query_content}" ] && [ "${command}" != "${query_package}" ]
		then
			frobulator.scs "Command provision found as reverse match" "[ '${query_package}' ]"
			echo

			install_list+=("${query_package}")

		else
			query_filter="$(apt-file search "${command}" | sed 's/ //' | sort -u | grep ^"${command}")"

			IFS=$'\n'

			query_filter=(${query_filter})

			IFS=''

			for selection in ${query_filter[@]}
			do
				query_filter="${selection}"

				query_package="$(echo "${query_filter}" | cut -d ':' -f 1)"
				query_content="$(echo "${query_filter}" | cut -d ':' -f 2)"

				query_command="${command}"

				if [ "${query_command}" != "${query_content}" ] && [ "${command}" = "${query_package}" ]
				then
					frobulator.scs "Command provision found as metapackage" "[ '${query_package}' ]"
					echo

					install_list+=("${query_package}")
				fi
			done
		fi

		# install

		if [[ "${#install_list[@]}" -ge 1 ]]
		then
			frobulator.install ${install_list[@]}

			install_list=()
		else
			frobulator.err "Command provision not found" "[ '${command}' ]"
			echo

			:
		fi

		# unset array

		list=()
	done
}

# reinstall ////////////////////////////////////////////////////////////////////

# use to reinstall package(s) from argument or array list

frobulator.reinstall () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_reinstall="apt-get --assume-yes install --reinstall"

	frobulator.inf "Reinstalling package(s)."
	echo

	for package in ${list[@]}
	do
		frobulator.log "${command_reinstall} ${package}" &

		frobulator.progress "Reinstalling..."
		echo
	done

	# unset array

	list=()

	# cleanup

	frobulator.clean
}

# update ///////////////////////////////////////////////////////////////////////

# use to update system package(s)

frobulator.update () {
	export DEBIAN_FRONTEND=noninteractive

	command_update="apt-get update"

	frobulator.inf "Processing package and repository information."
	echo

	frobulator.log "${command_update}" &

	frobulator.progress "Updating..."
	echo
}

# upgrade //////////////////////////////////////////////////////////////////////

# use to upgrade system packages

frobulator.upgrade () {
	export DEBIAN_FRONTEND=noninteractive

	command_upgrade="apt-get --assume-yes dist-upgrade"

	frobulator.inf "Processing installed package(s)."
	echo

	frobulator.log "${command_upgrade}" &

	frobulator.progress "Upgrading..."
	echo
}

# purge ////////////////////////////////////////////////////////////////////////

# use to purge package(s) from argument or array list

frobulator.purge () {
	export DEBIAN_FRONTEND=noninteractive

	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		package="${1}"

		list=()

		list+=("${package}")
	fi

	command_purge="apt-get --assume-yes purge --autoremove"

	frobulator.inf "Purging selected package(s)."
	echo

	for package in ${list[@]}
	do
		if [[ ! -z $(apt search "${package}" 2> /dev/null | grep -i -o installed) ]]
		then
			frobulator.wrn "Selecting" "[ '${package}' ]"
			echo

			frobulator.log "$(echo ${command_purge} ${package})" &

			frobulator.progress "Purging..."
			echo
		else
			frobulator.scs "Absent on system" "[ '${package}' ]"
			echo

			frobulator.fwd "Continuing..."
			echo

			:
		fi
	done

	# unset array

	list=()

	# cleanup

	frobulator.clean
}

# dialog ///////////////////////////////////////////////////////////////////////

# use to generate standard dialogs using desktop environement plugins:
# supports:
# gnome - zenity
# kde - kdialog

frobulator.dialog () {
	# dialog window title

	title="${script%.sh} - ${1}"

	dialog_command="${@}"

	# gtk dialog - zenity

	g_dialog () {
		zenity						\
			--file-selection		\
			--multiple				\
			--directory				\
			--separator=$'\n'		\
			--title="${title}"		"${dialog_command}"
	}

	# kde dialog - kdialog

	k_dialog () {
		kdialog						\
			--getopenfilename		\
			--multiple				\
			--separate-output		\
			--title "${title}"		"${dialog_command}"
	}

	# define dialog usage

	if [[ $(command -v zenity) ]]
	then
		dialog=$(g_dialog)

	elif [[ $(command -v kdialog) ]]
	then
		dialog=$(k_dialog)
	else
		frobulator.wrn "This utility must be run using the 'directory' option."
		echo

		frobulator.fwd "Exiting..."
		echo

		exit 1
	fi
}

# terminate ////////////////////////////////////////////////////////////////////

# use to forcefully terminate rogue processes

frobulator.terminate () {
	process_name="${1}"

	if [[ $(command -v pgrep) ]] && [[ $(command -v pkill) ]]
	then
		while [[ $(pgrep -f "${process_name}") ]]
		do
			pkill "${process_name}"
		done
	fi
}

# exit /////////////////////////////////////////////////////////////////////////

# use to exit process or program instance

frobulator.exit () {
	instance="${1}"

	frobulator.countdown 3 "Exiting" "[ ${instance} ]"

	frobulator.kill "${shell}"
}

# result ///////////////////////////////////////////////////////////////////////

# use to flag process checkpoint results such as installations and deployments

frobulator.result () {

	if [ $# -eq 1 ]
	then
		path="${PWD}"

		checkpoint="${1}"
		instance="${2}"
	else
		path="${1}"

		checkpoint="${2}"
		instance="${3}"
	fi

	if [ -f "${path}"/"${checkpoint}" ]
	then
		frobulator.scs "Setup complete" "[ ${instance} ]"
		echo
	else
		frobulator.err "Setup errors may have been encountered" "[ ${instance} ]"
		echo

		frobulator.inf "Review setup logs for details" '[ ${PREFIX}/var/log/ ]'
		echo
	fi
}

# user /////////////////////////////////////////////////////////////////////////

# use to identify 'user' name
# usefule for priviledged execution status checks

frobulator.user () {
	frobulator.msg "Current shell user name" "[ '${SUDO_USER:-$USER}' ]"
	echo

	sleep 1
}

# assess ///////////////////////////////////////////////////////////////////////

# use to assess 'superuser' status and prompt for priviledged execution
# useful for in-script dependency assessment and installation

frobulator.assess () {
	if [[ -n "${#list[@]}" ]]
	then
		# ${1} - array

		list=(${@:1})
	else
		command="${1}"

		list=()

		list+=("${command}")
	fi

	if [[ $(id -u -n) = "root" ]]
	then
		frobulator.require ${list[@]}

		frobulator.msg "Requirement(s) installed" "[ ${script} ]"
		echo

		frobulator.inf "Restart as '${USER}' to proceed." "[ '${script}' ]"
		echo
	else
		for command in ${list[@]}
		do
			if [[ -z $(command -v "${command}") ]]
			then
				frobulator.err "Missing" "[ '${command}' ]"
				echo

				frobulator.wrn "Privilege escalation required to proceed." "[ '${script}' ]"
				echo

				frobulator.ask "Launch as 'root'?"

				read reply
				echo

				if [[ "${reply}" = [yY] ]] || [[ "${reply}" = [yY][eE][sS] ]]
				then
					frobulator.escalate
				else
					frobulator.wrn "Launch as 'root' to install requirement(s)." "[ '${script}' ]"
					echo
				fi
			fi
		done
	fi

	# unset array

	list=()
}

# escalate /////////////////////////////////////////////////////////////////////

# use to provide priviledged execution
# restarts script process as 'superuser' once the status is granted

frobulator.escalate () {
	if [[ $(id -u -n) = "root" ]]
	then
		frobulator.inf "Setting up privileged execution" "[ '${USER}' ]"
		echo

		USER="${SUDO_USER}"

		HOME=/home/"${SUDO_USER}"
	else
		frobulator.wrn "Privilege escalation granted: restarting command" "[ 'root' ]"
		echo

		if [[ -z $(command -v sudo) ]]
		then
			frobulator.require sudo
		fi

		self="${0}"
		command="${@}"

		# set superuser password prompt

		export SUDO_PROMPT="[ $(tput setaf 3)${USER}$(tput sgr 0) ] >_ ? "

		# restart as superuser

		exec sudo "${shell}" "${self}" "${command}"
		echo
	fi
}


# archive //////////////////////////////////////////////////////////////////////

# use to archive content and for backup procedures

frobulator.archive () {
	list+=(
		7zip
		bzip2
		gzip
		rar
		tar
		zip
	)

	frobulator.install ${list[@]}

	# unset array

	list=()

	file="${1}"
	extension="${2}"
	directory="${3}"

	archive="${file}.${extension}"

	if [ -z "${directory}" ]
	then
		directory="${PWD}"
	fi

	if [ ! -d "${directory}" ]
	then
		echo
		frobulator.err "Unavailable" "[ '${directory}' ]"
		echo

		exit 1
	fi

	case "${extension}"
	in
		tar.bz2|tbz2)
			tar								\
				--create					\
				--bzip						\
				--file="${archive}"			"${directory}" > /dev/null 2>&1

				frobulator.inf "Archiving" "[ ${archive} ]"
				echo
		;;

		tar.gz|tgz)
			tar								\
				--create					\
				--gzip						\
				--file="${archive}"			"${directory}" > /dev/null 2>&1

				frobulator.inf "Archiving" "[ ${archive} ]"
				echo
		;;

		tar)
			tar								\
				--create					\
				--file="${archive}"			"${directory}" > /dev/null 2>&1

				frobulator.inf "Archiving" "[ ${archive} ]"
				echo
		;;

# 			bz2)
# 				bzip					\
# 					--stdout			\
# 					--keep				\
# 					--quiet				"${directory}" > "${archive}"
#
# 					frobulator.inf "Archiving" "[ ${archive} ]"
# 					echo
# 			;;

# 			gz)
# 				gzip					\
# 					--stdout			\
# 					--keep				\
# 					--quiet				"${directory}" > "${archive}"
#
# 					frobulator.inf "Archiving" "[ ${archive} ]"
# 					echo
# 			;;

		7z)
			7z a "${archive}" -o "${directory}" > /dev/null 2>&1

				frobulator.inf "Archiving" "[ ${archive} ]"
				echo
		;;

			*.rar)
 				rar a "${archive}" "${directory}" > /dev/null 2>&1

 					frobulator.inf "Archiving" "[ ${archive} ]"
 					echo
 			;;

		zip)
			zip								\
				-f							\
				-qq 						\
				-r "${archive}"				"${directory}"

				frobulator.inf "Archiving" "[ ${archive} ]"
				echo
		;;

		*)
			echo
			frobulator.err "Unsupported archive type" "[ '${archive}' ]"
			echo
		;;
	esac
}


# extract //////////////////////////////////////////////////////////////////////

# use to extract known archive types for script dependency or process resolution

frobulator.extract () {
	list+=(
		7z
		bunzip2
		gunzip
		tar
		unrar
		unzip
	)

	frobulator.install ${list[@]}

	# unset array

		list=()

	file="${1}"
	extension="${2}"
	directory="${3}"

	archive="${file}.${extension}"

	if [ -z "${directory}" ]
	then
		directory="${PWD}"
	fi

	if [ ! -d "${directory}" ]
	then
		mkdir -p "${directory}"
	fi

	if [ -f "${archive}" ]
	then
		case "${extension}"
		in
			*.tar.bz2|*.tbz2)
				tar								\
					--extract					\
					--bzip2						\
					--file="${archive}" 		\
					--directory="${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			tar.gz|*.tgz)
				tar								\
					--extract					\
					--gzip						\
					--file="${archive}" 		\
					--directory="${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			tar)
				tar								\
					--extract					\
					--file="${archive}" 		\
					--directory="${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo

			;;

			bz2)
				bzip							\
					--stdout					\
					--keep						\
					--quiet						\
					--decompress "${archive}"	> "${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			gz)
				gzip							\
					--stdout					\
					--keep						\
					--quiet						\
					--decompress "${archive}"	> "${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			7z)
				7z								\
					x "${archive}" 				\
					-o "${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			rar)
				unrar e "${archive}" "${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			zip)
				unzip							\
					-o							\
					-qq "${archive}"			\
					-d "${directory}"

					frobulator.inf "Extracting" "[ ${archive} ]"
					echo
			;;

			*)
				echo
				frobulator.err "Extraction failed" "[ '${archive}' ]"
				echo
			;;
		esac
	else
		echo
		frobulator.err "Unsupported archive type" "[ '${archive}' ]"
		echo
	fi
}
